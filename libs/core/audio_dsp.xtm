;;; audio_dsp.xtm -- audio DSP library

;; Author: Andrew Sorensen
;; Keywords: extempore
;; Required dylibs: 

;;; Commentary:

;; Please keep in mind that these functions
;; are provided as EXAMPLES ONLY.  They are
;; things that I've thown together and are
;; not to be considered "production" in any way.
;; In particular they are very very inefficient!!
;;
;; Please feel free to fix things and contribute
;; extra juicy bits and pieces
;;
;; Contains:
;; Sine, Square, Saw, Pulse waves
;; Delay, TapDelay, Comb (variable length delay)
;; AllPass, Reverb, Flanger and Chorus
;; LowPass, HighPass, BandPass and Notch filters
;; BitCrusher

;;; Code:

;; do you want to compile multichannel extensions
;; usually NOT
(define *build-multi-chan* #f)

;; bind some global audio values
(if (not (llvm:get-globalvar "SAMPLERATE"))
    (bind-val SAMPLERATE double (integer->real *au:samplerate*)))
(if (not (llvm:get-globalvar "CHANNELS"))
    (bind-val CHANNELS i64 *au:channels*))
(if (not (llvm:get-globalvar "IN_CHANNELS"))
    (bind-val IN_CHANNELS i64 *au:in-channels*))
(if (not (llvm:get-globalvar "FRAMES"))
    (bind-val FRAMES i64 *au:block-size*))

(bind-alias DSP [double,double,double,double,double*]*)

(bind-func print_audio_state
  (lambda ()
    (printf "    FRAMES: %lld\n" FRAMES)
    (printf " OUT CHANS: %lld\n" CHANNELS)
    (printf "  IN CHANS: %lld\n" IN_CHANNELS)
    (printf "SAMPLERATE: %f\n" SAMPLERATE)))

(print_audio_state)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; silence
(bind-func dsp:DSP
  (lambda (in time chan dat)
    0.0))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html

(bind-func dsp_randn
  (let ((phase 0))
    (lambda ()
      (let ((u1 (random))
	    (u2 (random))
	    (v1 (- (* 2.0 u1) 1.0))
	    (v2 (- (* 2.0 u2) 1.0))
	    (s (+ (* v1 v1) (* v2 v2))))
	(if (= phase 0)
	    (if (or (> s 1.0) (= s 0.0) (= s 1.0))
		(dsp_randn)
		(* v1 (sqrt (/ (* -2.0 (log s)) s))))
	    (begin (set! phase (- 1 phase))
		   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))

;; high limit
;; low limit
;; then value
(bind-func range_limit
  (lambda (h:double l:double v:double)
    (if (< v l) l
	(if (> v h) h
	    v))))

;; x values must fall within the range -PI ... PI
(bind-func _sin
  (let ((p 0.225) ; :_abuf* (alloc))
	(b (/ 4.0 PI))
	(c (/ -4.0 (* PI PI))))
    (lambda (x)
      (let ((y (+ (* b x) (* c x (fabs x)))))
	(+ (* p (- (* y (fabs y)) y)) y)))))

;; (bind-func osc_c
;;   (lambda (phase)
;;     (lambda (amp freq)
;;       (let ((inc (* TWOPI (/ freq SAMPLERATE))))
;; 	(set! phase (+ phase inc))
;; 	(* amp (sin phase))))))


(bind-func osc_c
  (lambda (phase)
    (lambda (amp freq)
      (let ((inc (* TWOPI (/ freq SAMPLERATE))))
	(set! phase (+ phase inc))
	(if (> phase PI) (set! phase (- phase TWOPI)))
	(* amp (_sin phase))))))


(if *build-multi-chan*
    (bind-func osc_mc_c
      (lambda (phase)
	(let ((mem 0.0)
	      (osc (osc_c phase)))
	  (lambda (chan amp freq)
	    (if (< chan 1.0) (set! mem (osc amp freq)))
	    mem)))))


;; square oscillator
(bind-func square_c
  (lambda (phase)   
    (let ((osc (osc_c phase))	  
	  (n 50.0))         
      (lambda (amp freq)
	(* amp (tanh (* n (osc 1.0 freq))))))))


;; square oscillator multichannel
(if *build-multi-chan*
    (bind-func square_mc_c
      (lambda (phase)   
	(let ((sqr (square_c phase))
	      (mem 0.0))
	  (lambda (chan amp freq)	
	    (if (< chan 1.0) (set! mem (sqr amp freq)))
	    mem)))))

;; rect wave oscillator - useful for pulse width modulation
(bind-func rect_c
  (lambda (phase)
    (lambda (amp freq duty)
      (let ((inc (/ freq SAMPLERATE)))
	(set! phase (+ phase inc))
	(if (> phase 1.0) (set! phase (- phase 1.0)))
	(if (< phase duty) amp (* -1.0 amp))))))

;; saw oscillator
(bind-func saw_c
  (lambda ()
    (let ((p 0.0)
	  (dp 1.0)
	  (x 0.0)
	  (leak 0.995)
	  (saw 0.0))
      (lambda (amp freq)
	(let* ((qmax (* 0.5 (/ SAMPLERATE freq)))
	       (dc (/ -0.498 qmax)))
	  (set! p (+ p dp))
	  (if (< p 0.0) 
	      (begin (set! p (- 0.0 p))
		     (set! dp (- 0.0 dp)))
	      (if (> p qmax)
		  (begin (set! p (+ qmax (- qmax p)))
			 (set! dp (- 0.0 dp)))))
	  (set! x (* PI p))
	  (if (< x 0.000001) (set! x 0.00001))
	  (set! saw (* leak (+ saw (+ dc (/ (sin x) x)))))
	  (* amp saw))))))


;; saw oscillator
(if *build-multi-chan*
    (bind-func saw_mc_c
      (lambda ()
	(let ((mem 0.0)
	      (saw (saw_c)))
	  (lambda (chan amp freq)
	    (if (< chan 1.0) (set! mem (saw amp freq)))
	    mem)))))

;; white noise generator
(bind-func white_c
  (lambda ()
    (lambda ()
      (* 0.33 (dsp_randn)))))

;; pink noise generator
;; uses Paul Kellet's economy method
;; http://www.firstpr.com.au/dsp/pink-noise/
(bind-func pink_c
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0))
      (lambda ()
        (set! b0 (+ (* b0 0.99765) (* (dsp_randn) 0.0555179)))
        (set! b1 (+ (* b1 0.96300) (* (dsp_randn) 0.2965164)))
        (set! b2 (+ (* b2 0.57000) (* (dsp_randn) 1.0526913)))
        (* 0.33 (+ b0 b1 b2 (* (dsp_randn) 0.1848)))))))

;; pulse train
(bind-func pulse_c
  (lambda ()
    (let ((time -1.0)
	  (width 100.0))
      (lambda (amp:double freq)
	(let ((period (/ SAMPLERATE freq)))
	  (set! time (+ time 1.0))
	  (if (< (modulo time period) width)
	      amp
	      0.0))))))

(if *build-multi-chan*
    (bind-func pulse_mc_c
      (lambda ()
	(let ((pulse (pulse_c))
	      (mem 0.0))
	  (lambda (chan amp freq)
	    (if (< chan 1.0) (set! mem (pulse amp freq)))
	    mem)))))


;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
(bind-func delay_c
  (lambda (max_delay)
    (let ((line:double* (zalloc max_delay))
	  (time 0)
	  (delay max_delay)
	  (in 0.5)
	  (out 0.5))
      (lambda (x:double)
	(let* ((n (modulo time delay))
	       (delayed (pref line n))
	       (y (+ (* in x) (* out delayed))))
	  (pset! line n y)
	  (set! time (+ time 1))
	  y)))))

(if *build-multi-chan*
    (bind-func delay_mc_c
      (lambda (channels:i64 max_delay)
	(let ((dlines:[double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (delay_c max_delay)))
	  (lambda (chan x)
	    ((pref dlines (dtoi32 chan)) x))))))


;; iir comb with interpolation
(bind-func comb_c
  (lambda (max_delay)
    (let ((line:double* (zalloc max_delay))
	  (in_head 0)
	  (out_head 0)
	  (delay_ (i64tod max_delay))
	  ;;(delay (i64tod max_delay))
	  (alpha 0.0)
	  (om_alpha 1.0)
	  (in 1.0)
	  (i 0)
	  (out 0.5))
      (dotimes (i max_delay) (pset! line i 0.0))
      (lambda (x:double delay:double)
	(if (<> delay delay_)
	    (begin (set! delay_ delay)		 
		   (set! alpha (- delay (floor delay)))
		   (set! om_alpha (- 1.0 alpha))
		   (set! out_head (- (+ max_delay in_head)
				     (dtoi64 delay)))))
	(let* ((ih:i64 (modulo in_head max_delay))
	       (oh:i64 (modulo out_head max_delay))
	       (delayed1 (pref line oh))
	       (delayed2 (pref line (modulo (+ oh 1) max_delay)))
	       (delayed (+ (* alpha delayed1) (* om_alpha delayed2))) 
	       (y (+ (* in x) (* out delayed))))
	  (pset! line ih y)
	  (set! in_head (+ ih 1))
	  (set! out_head (+ oh 1))
	  y)))))


(if *build-multi-chan*
    (bind-func comb_mc_c
      (lambda (channels:i64 max_delay)
	(let ((dlines:[double,double]** (alloc channels))
	      ;;(delay (i64tod max_delay))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (comb_c max_delay)))
	  (lambda (chan x delay)
	    (let ((f (pref dlines (dtoi32 chan))))
	      (f x delay)))))))


;; flanger
(bind-func flanger_c
  (lambda (delay mod_phase mod_range mod_rate)
    (let ((comb (comb_c (dtoi64 (+ delay mod_range))))
	  (mod (osc_c mod_phase)))
      (lambda (x:double)
	(comb x (+ delay (mod mod_range mod_rate)))))))


(if *build-multi-chan*
    (bind-func flanger_mc_c
      (lambda (channels:i64 delay mod_phase mod_range mod_rate)
	(let ((comb (comb_mc_c channels (dtoi64 (+ delay mod_range))))
	      (mod (osc_mc_c mod_phase))
	      (i:i64 0))
	  (lambda (chan x)
	    (comb chan x (+ delay (mod chan mod_range mod_rate))))))))


;; chorus
(bind-func chorus_c
  (lambda (phase)
    (let ((delay 700.0)
	  (range 200.0)
	  (rate 0.1)
	  (comb1 (comb_c (dtoi64 (+ delay range))))
	  (comb2 (comb_c (dtoi64 (+ delay range))))
	  (comb3 (comb_c (dtoi64 (+ delay range))))
	  (mrng1 range)
	  (mrng2 (* (random) range))
	  (mrng3 (* (random) range))
	  (mrte1 rate)
	  (mrte2 (* rate 1.372))
	  (mrte3 (* rate 0.792))
	  (dly1 delay)
	  (dly2 (* (random) delay))
	  (dly3 (* (random) delay))
	  (mod1 (osc_c phase))
	  (mod2 (osc_c phase))
	  (mod3 (osc_c phase)))
      (comb1.in .5)
      (comb2.in .5)
      (comb3.in .5)
      (lambda (x:double)
	(+ (comb1 x (+ dly1 (mod1 mrng1 mrte1)))
	   (comb2 x (+ dly2 (mod2 mrng2 mrte2)))
	   (comb3 x (+ dly3 (mod3 mrng3 mrte3))))))))

(if *build-multi-chan*
    (bind-func chorus_mc_c
      (lambda (channels:i64 phase)
	(let ((dlines:[double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (chorus_c phase)))
	  (lambda (chan x)
	    (let ((f (pref dlines (dtoi32 chan))))
	      (f x)))))))


;; tap delay
(bind-func tap_delay_c
  (lambda (max_delay num_of_taps)
    (let ((line:double* (zalloc max_delay))
	  (taps:i64* (zalloc num_of_taps))
	  (delay max_delay)
	  (time 0))
      (lambda (x:double)
	(let ((y 0.0)
	      (i 0)
	      (n (modulo time delay))
	      (gain (/ 1.0 (i64tod num_of_taps))))
	  (pset! line n x)
	  (dotimes (i num_of_taps)
	    (set! y (+ y (* gain (pref line (modulo (+ (pref taps i) n) delay))))))
	  (set! time (+ time 1))
	  y)))))

;; allpass
(bind-func allpass_c
  (lambda (delay)
    (let ((inline:double* (zalloc delay))
	  (outline:double* (zalloc delay))
	  (time 0)
	  (g 0.9))
      (lambda (x)
	(let* ((n (modulo time delay))
	       (dy (pref outline n))
	       (dx (pref inline n))
	       (y (+ (* -1.0 g x)
		     dx
		     (* g dy))))
	  (pset! inline n x)
	  (pset! outline n y)
	  (set! time (+ time 1))
	  y)))))

(if *build-multi-chan*
    (bind-func allpass_mc_c
      (lambda (channels:i64 delay)
	(let ((lines:[double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (allpass_c delay)))
	  (lambda (chan x)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x)))))))


;; a dodgy reverb
;; (bind-func reverb_c
;;   (lambda (size) ; size in ms
;;     (let ((ms (/ SAMPLERATE 1000.0))
;; 	  (wet .25)
;; 	  (dly1 (delay_c (dtoi64 (* ms (* .192 size)))))
;; 	  (dly2 (delay_c (dtoi64 (* ms (* .373 size)))))
;; 	  (dly3 (delay_c (dtoi64 (* ms (* .671 size)))))
;; 	  (dly4 (delay_c (dtoi64 (* ms (* .712 size)))))
;; 	  (ap1 (allpass_c (dtoi64 (* ms size))))
;; 	  (ap2 (allpass_c (dtoi64 (* ms (* .329 size))))))
;;       (ap1.g .8)
;;       (ap2.g .8)
;;       (lambda (in)
;; 	(let ((wetin (* in wet)))
;; 	  (+ (* in (- 1.0 wet)) (ap1 (ap2 (+ (dly1 wetin)
;; 					     (dly2 wetin)
;; 					     (dly3 wetin)
;; 					     (dly4 wetin))))))))))



;; a dodgy reverb mk2
(bind-func reverb_c
  (lambda (size) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
	  (dly1 (delay_c (dtoi64 (* ms (* .192 size)))))
	  (dly2 (delay_c (dtoi64 (* ms (* .373 size)))))
	  (dly3 (delay_c (dtoi64 (* ms (* .671 size)))))
	  (dly4 (delay_c (dtoi64 (* ms (* .712 size)))))
	  (ap1 (allpass_c (dtoi64 (* ms size))))
	  (ap3 (allpass_c (dtoi64 (* ms (* .929 size)))))
	  (ap2 (allpass_c (dtoi64 (* ms (* .329 size))))))
      (ap1.g .8)
      (ap2.g .7)
      (ap3.g .6)
      (lambda (in wet)
	(let ((wetin (* in wet)))
	  (+ (* in (- 1.0 wet))
	     (ap1 (ap2 (ap3 (+ (dly1 wetin)
			       (dly2 wetin)
			       (dly3 wetin)
			       (dly4 wetin)))))))))))

(if *build-multi-chan*
    (bind-func reverb_mc_c
      (lambda (channels:i64 size)
	(let ((lines:[double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (reverb_c size)))
	  (lambda (chan x)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x)))))))


;; a dodgy bitcrusher
(bind-func crusher_c
  (lambda ()
    (let ((amp 1.0))
      (lambda (in bits)
	(* amp (/ (floor (* in (pow 2. bits))) 
		  (pow 2. bits)))))))


;; a dodgy amp distortion
(bind-func distort_c
  (lambda (gain)
    (let ((lim 0.5))
      (lambda (in)
	(range_limit lim (* -1.0 lim) (* gain in))))))

;; a four channel mixer
(bind-func mixquad
  (lambda (c1 c2 c3 c4 chan in:double)
    (cond ((< chan 1.0) (* in c1))
	  ((< chan 2.0) (* in c2))
	  ((< chan 3.0) (* in c3))
	  ((< chan 4.0) (* in c4))
	  (else 0.0))))

;; a four channel mixer
;; cdat is an array of doubles values
;; each array element is a channels mix (between 0.0 and 1.0)
(bind-func mixer_c
  (lambda (channels:i64)
    (let ((ch (i64tod channels)))
      (lambda (cdat:double* chan:double in:double)
	(if (< chan channels)
	    (* in (pref cdat (dtoi32 chan)))
	    0.0)))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; BiQuad coefficient formulae from 
;; Audio EQ Cookbook Robert Bristow-Johnson
;;
;; http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; biquad low-pass filter
(bind-func lpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (oldres 0.0)
	   (oldfreq 0.0))
      (lambda (x freq res)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> freq oldfreq)
		(<> res oldres))
	    (let* ((omega (* TWOPI (/ freq SAMPLERATE)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (/ sino (* 2.0 res))))
	      (set! oldfreq freq)
	      (set! oldres res)
	      (set! b0 (/ (- 1.0 coso) 2.0))
	      (set! b1 (- 1.0 coso))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((y (- (+ (* (/ b0 a0) x)
		       (* (/ b1 a0) x1)
		       (* (/ b2 a0) x2))
		    (* (/ a1 a0) y1)
		    (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 y)
	  (set! x2 x1)
	  (set! x1 x)
	  y)))))

(if *build-multi-chan*
    (bind-func lpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (lpf_c)))
	  (lambda (chan x freq res)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x freq res)))))))


;; biquad high-pass filter
(bind-func hpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (oldres 0.0)
	   (oldfreq 0.0))
      (lambda (x freq res)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> freq oldfreq)
		(<> res oldres))
	    (let* ((omega (* TWOPI (/ freq SAMPLERATE)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (/ sino (* 2.0 res))))
	      (set! oldfreq freq)
	      (set! oldres res)
	      (set! b0 (/ (+ 1.0 coso) 2.0))
	      (set! b1 (* -1.0 (+ 1.0 coso)))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((y (- (+ (* (/ b0 a0) x)
		       (* (/ b1 a0) x1)
		       (* (/ b2 a0) x2))
		    (* (/ a1 a0) y1)
		    (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 y)
	  (set! x2 x1)
	  (set! x1 x)
	  y)))))

(if *build-multi-chan*
    (bind-func hpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (hpf_c)))
	  (lambda (chan x freq res)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x freq res)))))))


;; biquad band-pass filter
(bind-func bpf_c
  (lambda () 
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (oldfreq 0.0)
	   (oldbw 0.0))
      ;; bandwidth in octaves
      (lambda (x freq bandwidth)
	;; if frequency or bandwidth change
	;; recalculate coefficients
	(if (or (<> freq oldfreq)
		(<> bandwidth oldbw))
	    (let* ((omega (* 1.0 TWOPI (/ freq SAMPLERATE)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (* (/ (log2 2.0) 2.0)
					   bandwidth
					   (/ omega sino))))))
	      (set! oldfreq freq)
	      (set! oldbw bandwidth)
	      (set! b0 alpha)
	      (set! b1 0.0) 
	      (set! b2 (* -1.0 b0))
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((y (- (+ (* (/ b0 a0) x)
		       (* (/ b1 a0) x1)
		       (* (/ b2 a0) x2))
		    (* (/ a1 a0) y1)
		    (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 y)
	  (set! x2 x1)
	  (set! x1 x)
	  y)))))


(if *build-multi-chan*
    (bind-func bpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (bpf_c)))
	  (lambda (chan x freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x freq bandwidth)))))))


;; biquad notch filter
(bind-func notch_c
  (lambda () 
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)	     
	   (oldfreq 0.0)
	   (oldbw 0.0))
      ;; bandwidth in octaves
      (lambda (x freq bandwidth)
	;; if frequency or bandwidth change
	;; recalculate coefficients
	(if (or (<> freq oldfreq)
		(<> bandwidth oldbw))
	    (let* ((omega (* TWOPI (/ freq SAMPLERATE)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (* (/ (log2 2.0) 2.0)
					   bandwidth
					   (/ omega sino))))))
	      (set! oldfreq freq)
	      (set! oldbw bandwidth)
	      (set! b0 1.0)
	      (set! b1 (* -2.0 coso)) 
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 b1)
	      (set! a2 (- 1.0 alpha))))
	(let ((y (- (+ (* (/ b0 a0) x)
		       (* (/ b1 a0) x1)
		       (* (/ b2 a0) x2))
		    (* (/ a1 a0) y1)
		    (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 y)
	  (set! x2 x1)
	  (set! x1 x)
	  y)))))

(if *build-multi-chan*
    (bind-func notch_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (notch_c)))
	  (lambda (chan x freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x freq bandwith)))))))

;; Hilbert transform filter

(bind-func hilbert_c
  "n = filter order (should be 2^n + 1)"
  (lambda (n)
    (let ((i 0)
          (h_n:double* (alloc n))
          (x_n:double* (alloc n))
          (x_ptr 0))
      ;; h[i] = (2/(i*pi))*sin^2((i*pi)/2) for i=-n/2,...,n/2
      (dotimes (i n (/ (* n -1) 2))
        (pset! h_n
               (+ i (/ n 2))
               (* (/ 2.0 (* (i64tod i) PI))
                  (pow (sin (/ (* (i64tod i) PI) 2.0)) 2.0))))
      ;; h[0] = 0
      (pset! h_n (+ 1 (/ n 2)) 0.0)
      (lambda (x)
        (pset! x_n x_ptr x)
        (let ((out 0.0))
          (dotimes (i n)
            (set! out (+ out (* (pref h_n i)
                                (pref x_n (modulo (+ i x_ptr (- n 1)) n))))))
          (modulo (set! x_ptr (+ x_ptr 1)) n)
          out)))))

(bind-func env_follow_c
  (lambda (n)
    (let ((hilb (hilbert_c n)))
      (lambda (x)
        (sqrt (+ (pow x 2.0)
                 (pow (hilb x) 2.0)))))))

;;
;; moog VCF
;;
;; from Stilson/Smith CCRMA
;;
(bind-func vcf_c
  (lambda ()
    (let ((x 0.0) (y1 0.0) (y2 0.0) (y3 0.0) (y4 0.0)
	  (oldx 0.0) (oldy1 0.0) (oldy2 0.0) (oldy3 0.0))
      (lambda (in cutoff res)
	(let ((f (* 1.75 (/ cutoff SAMPLERATE)))
                                        ;(k (- (* 2.0 (sin (* f (/ PI 2.0)))) 1.0))
	      (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
	      (p (* 0.5 (+ k 1.0)))
	      (scale (exp (* (- 1.0 p) 1.386249)))
	      (r (* res scale)))
	  (set! x (- in (* r y4)))
	  (set! y1 (+ (* x  p) (* oldx  p) (* -1.0 k y1)))
	  (set! y2 (+ (* y1 p) (* oldy1 p) (* -1.0 k y2)))
	  (set! y3 (+ (* y2 p) (* oldy2 p) (* -1.0 k y3)))
	  (set! y4 (+ (* y3 p) (* oldy3 p) (* -1.0 k y4)))

	  (set! oldx x) (set! oldy1 y1) (set! oldy2 y2) (set! oldy3 y3)
	  ;; y4 is output
	  (set! y4 (- y4 (/ (pow y4 3.0) 6.0)))
	  y4)))))

(if *build-multi-chan*
    (bind-func vcf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double]** (alloc channels))
	      (res 0.5)
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (vcf_c)))
	  (lambda (chan x freq)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f.res res)
	      (f x freq)))))))

;;
;; moog VCF v2.0
;;
;; from Stilson/Smith CCRMA
;;
(bind-func vcf2_c
  (lambda ()
    (let ((res 0.5) ;; 0.0 - 1.0
	  (in1 0.0) (in2 0.0) (in3 0.0) (in4 0.0)
	  (out1 0.0) (out2 0.0) (out3 0.0) (out4 0.0))
      (lambda (in cutoff)
	(let ((f (/ (* 7.0 cutoff) (* 1.16 SAMPLERATE))) ;1.16))
	      (f1 (- 1.0 f))
	      (fb (* res 4.0 (- 1.0 (* 0.15 f f)))))
	  (set! in (- in (* out4 fb)))
	  (set! in (* in 0.35013 f f f f))
	  (set! out1 (+ in   (* 0.3 in1) (* f1 out1))) ;; Pole 1
	  (set! in1 in)
	  (set! out2 (+ out1 (* 0.3 in2) (* f1 out2)))  ;; Pole 2	  
	  (set! in2 out1)
	  (set! out3 (+ out2 (* 0.3 in3) (* f1 out3)))  ;; Pole 3
	  (set! in3 out2)
	  (set! out4 (+ out3 (* 0.3 in4) (* f1 out4)))  ;; Pole 4	  
	  (set! in4 out3)
	  out4)))))


(if *build-multi-chan*
    (bind-func vcf2_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double]** (alloc channels))
	      (res 0.5)
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (vcf2_c)))
	  (lambda (chan x freq)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f.res res)
	      (f x freq)))))))

;; State Variable Filter adapted from
;; http://www.musicdsp.org/archive.php?classid=3#142 (it is possible
;; to get all the hp, lp, bp and notch output values in one function,
;; however they are currently provided in separate functions)

(if (not (llvm:get-globalvar "SVF_LOWPASS"))
    (bind-val SVF_LOWPASS i64 1))
(if (not (llvm:get-globalvar "SVF_HIGHPASS"))
    (bind-val SVF_HIGHPASS i64 2))
(if (not (llvm:get-globalvar "SVF_BANDPASS"))
    (bind-val SVF_BANDPASS i64 3))
(if (not (llvm:get-globalvar "SVF_NOTCH"))
    (bind-val SVF_NOTCH i64 4))
(if (not (llvm:get-globalvar "SVF_PEAK"))
    (bind-val SVF_PEAK i64 5))

(bind-func min2d
  (lambda (a:double b)
    (if (< a b) a b)))

(bind-func svf_c
  "Returns a (state variable) filter closure"
  (lambda (type)
    ;; old values
    (let ((cutoff_ 0.0)
          (resonance_ 0.0)
          (drive 0.0)
          (freq 0.0)
          (damp 0.0)
          (notch 0.0)
          (low 0.0)
          (high 0.0)
          (band 0.0)
          (peak 0.0)
          (out 0.0))
      (lambda (in cutoff resonance)
        ;; recalculate some values if cutoff or resonance have changed
        (if (or (<> cutoff cutoff_)
                (<> resonance resonance_))
            (begin
              (set! cutoff_ cutoff)
              (set! resonance_ resonance)
              (set! freq (* 2.0 (sin (* PI (min2d 0.25 (/ cutoff (* SAMPLERATE 2.0)))))))
              (set! damp (min2d (* 2.0 (- 1.0 (pow resonance 0.25)))
                                (min2d 2.0 (- (/ 2.0 freq) (* freq 0.5)))))))
        (set! notch (- in (* damp band)))
        (set! low (+ low (* freq band)))
        (set! high (- notch low))
        (set! band (- (+ (* freq high) band)
                      (* drive band band band)))
        ;; this is a bit filthy - needs a macro
        (set! out (* 0.5 (if (= type SVF_LOWPASS)
                             low
                             (if (= type SVF_HIGHPASS)
                                 high
                                 (if (= type SVF_BANDPASS)
                                     band
                                     (if (= type SVF_NOTCH)
                                         notch
                                         (if (= type SVF_PEAK)
                                             peak
                                             0.0)))))))
        ;; now do it all again (because it's oversampled for
        ;; stability)
        (set! notch (- in (* damp band)))
        (set! low (+ low (* freq band)))
        (set! high (- notch low))
        (set! band (- (+ (* freq high) band)
                      (* drive band band band)))
        ;; this is a bit filthy - needs a macro
        (set! out (+ out (* 0.5 (if (= type SVF_LOWPASS)
                                    low
                                    (if (= type SVF_HIGHPASS)
                                        high
                                        (if (= type SVF_BANDPASS)
                                            band
                                            (if (= type SVF_NOTCH)
                                                notch
                                                (if (= type SVF_PEAK)
                                                    peak
                                                    0.0))))))))))))

;; based on Steve Harris's foverdrive lv2 plugin
;; http://plugin.org.uk/

(bind-func overdrive_c
  "Drive range:[1.0,3.0]"
  (lambda (drive)
    (let ((drive_minus_1 (- drive 1.0)))
      (lambda (x)
        (let ((absx (fabs x)))
          (/ (* x (+ absx drive))
             (+ (* x x)
                (* drive_minus_1 absx)
                1.0)))))))

;; based on Steve Harris's Valve Saturation lv2 plugin
;; http://plugin.org.uk/

(bind-func saturation_c
  "level:[0.0,1.0] character:[0.0,1.0]"
  (lambda ()
    (let ((itm1 0.0)
          (otm1 0.0))
      (lambda (x level character)
        (let ((q (- level 0.999))
              (dist (+ (* character 40.0) 0.1))
              (fx (if (= x q)
                      (/ (/ 1.0 (+ dist q))
                         (- 1.0 (exp (* dist q))))
                      (/ (/ (- x q)
                            (+ (- 1.0 (exp (* -1.0 dist (- x q)))) q))
                         (- 1.0 (exp (* dist q)))))))
          (set! otm1 (- (+ (* 0.999 otm1) fx) itm1))
          (set! itm1 fx)
          otm1)))))

(bind-func ringmod_c
  "freq feedback:[0.0,1.0]"
  (lambda ()
    (let ((osc (osc_c 0.0)))
      (lambda (x freq feedback)
        (+ (* (- 1.0 feedback) x)
           (* feedback (* x (osc freq 1.0))))))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; envelope stuff
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; time in samples (starting from 0)
;; apex (in samples) is after how many samples we hit 1.0 before decaying
(bind-func impulse
  (lambda (time:double apex:double)
    (let ((h (* time apex)))
      (* h (exp (- 1.0 h))))))


(bind-func line_c
  (lambda (x1:double y1:double x2 y2)
    (let* ((m (if (= 0.0 (- x2 x1)) 
		  0.0 
		  (/ (- y2 y1) (- x2 x1))))
	   (c (- y2 (* m x2))))
      (lambda (time) (+ (* m time) c)))))


(bind-func envelope_segments
  (lambda (points:double* num_of_points:i64)
    (let ((lines:[double,double]** (zalloc num_of_points))
	  (k 0))
      (dotimes (k num_of_points)
	(let* ((idx (* k 2))
	       (x1 (pref points (+ idx 0)))
	       (y1 (pref points (+ idx 1)))
	       (x2 (pref points (+ idx 2)))
	       (y2 (pref points (+ idx 3))))
	  (pset! lines k (line_c x1 y1 x2 y2))))
      lines)))

(bind-func envelope_c
  (lambda (points:double* num_of_points)
    (let ((klines:[double,double]** (envelope_segments points num_of_points))
	  (line_length num_of_points))
      (lambda (time)
	(let ((res -1.0)
	      (k:i64 0))
	  (dotimes (k num_of_points)
	    (let ((line (pref klines k))
		  (time_point (pref points (* k 2))))
	      (if (or (= time time_point)
		      (< time_point time))
		  (set! res (line time)))))
	  res)))))

;; make a convenience wrapper for asr
(bind-func adsr_c
  (lambda (start_time atk_dur dky_dur sus_dur rel_dur peak_amp sus_amp)
    (let* ((points 6)
	   (data:double* (zalloc (* points 2))))
      (pset! data 0 start_time)
      (pset! data 1 0.0)
      (pset! data 2 (+ start_time atk_dur)) ;; point data
      (pset! data 3 peak_amp)
      (pset! data 4 (+ start_time atk_dur dky_dur))
      (pset! data 5 sus_amp)
      (pset! data 6 (+ start_time atk_dur dky_dur sus_dur))
      (pset! data 7 sus_amp)
      (pset! data 8 (+ start_time atk_dur dky_dur sus_dur rel_dur))
      (pset! data 9 0.0)
      (pset! data 10 (+ start_time atk_dur dky_dur sus_dur rel_dur 1.0)) ;; this to flatten out at 0.0
      (pset! data 11 0.0)
      (let ((f (envelope_c data points)))
	(lambda (time:double)
	  (f time))))))


;; an accumulative adsr (random access not allowed! time must be linear).
(bind-func adsr_accum_c
  (lambda (start_time:double atk_dur dky_dur sus_dur rel_dur peak_amp sus_amp)
    (let ((val (if (> (+ atk_dur dky_dur) 1.0) 0.0 peak_amp))
	  (t1 atk_dur)
	  (t2 (+ atk_dur dky_dur))
	  (t3 (+ atk_dur dky_dur sus_dur))
	  (t4 (+ atk_dur dky_dur sus_dur rel_dur))	  
	  (inc1 (/ peak_amp atk_dur))
	  (inc2 (* -1.0 (/ (- peak_amp sus_amp) dky_dur)))
	  (inc3 (* -1.0 (/ sus_amp rel_dur))))
      (lambda (time:double chan)
	(if (< chan 1.0)
	    (cond ((> time t4) (set! val 0.0))
		  ((> time t3) (set! val (+ val inc3)))
		  ((> time t2) val) ;; sustain (don't do anything with val)
		  ((> time t1) (set! val (+ val inc2)))
		  ((> time 0) (set! val (+ val inc1)))
		  (else (set! val 0.0))))
	val))))

(bind-func hermite_interp
  (lambda (fractional y1:double x0 x1 x2)
    (let ((c (* 0.5 (- x1 y1)))
	  (v (- x0 x1))
	  (w (+ c v))
	  (a (+ w v (* (- x2 x0) 0.5)))
	  (b (+ w a)))
      (+ (* (+ (* (- (* a fractional) b) fractional) c) fractional) x0))))

;; linear fade closure

(bind-func fade_c
  (lambda (phase)
    (lambda (amp freq)
      (let ((inc (/ freq SAMPLERATE)))
	(if (> phase 1.0)
            amp
            (begin (set! phase (+ phase inc))
                   (* phase amp)))))))

;;  midi/freq utilities

(bind-func midi2frq    
  (lambda (pitch)            
    (* 440.0 (pow 2.0 (/ (- pitch 69.0) 12.0)))))

(bind-func frq2midi
  (lambda (freq)            
    (+ (* 12.0 (log2 (/ freq 440.0))) 69.0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; An ipc helper for audio
;;

(define ipc:audio-setup
  (lambda (proc)
    (ipc:eval-string proc
		     "(define-macro (play-note time inst pitch vol dur)
			 `(let ((duration (* 1.0 ,dur))
				(native (llvm:get-native-closure ,(symbol->string inst))))
			    (if (cptr? native)
				(_play_note (integer->real ,time)
					     native
					     (midi2frq (* 1.0 ,pitch))
					     (/ (exp (/ ,vol 26.222)) 127.0)
					     duration)
				(print-error 'No 'inst 'named ,(symbol->string inst)))))")
    (ipc:bind-func proc '_play_note)
    (ipc:bind-func proc 'midi2frq)))

;; (ipc:audio-setup "utility")
