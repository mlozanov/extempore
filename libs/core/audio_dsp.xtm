;;; audio_dsp.xtm -- audio DSP library

;; Author: Andrew Sorensen
;; Keywords: extempore
;; Required dylibs: 

;;; Commentary:

;; Please keep in mind that these functions
;; are provided as EXAMPLES ONLY.  They are
;; things that I've thown together and are
;; not to be considered "production" in any way.
;; In particular they are very very inefficient!!
;;
;; Please feel free to fix things and contribute
;; extra juicy bits and pieces
;;
;; Contains:
;; Sine, Square, Saw, Pulse waves
;; Delay, TapDelay, Comb (variable length delay)
;; AllPass, Reverb, Flanger and Chorus
;; LowPass, HighPass, BandPass and Notch filters
;; BitCrusher

;;; Code:

;; if not primary process
(if (not (ipc:get-process-name "primary"))
    (sys:load-escape "Please load xtm libraries into the primary process"))
;; if already loaded then break!
(if (defined? 'xtmlib_audio_loaded)
    (sys:load-escape "Audio already loaded")) ;; break to top level

(define xtmlib_audio_loaded #t)

;; do you want to compile multichannel extensions
;; usually NOT
(define *build-multi-chan* #t)

;; bind some global audio values
(if (not (llvm:get-globalvar "SAMPLERATE"))
    (begin (bind-val SAMPLERATE double (integer->real *au:samplerate*))
           (bind-val SR double (integer->real *au:samplerate*))))
(if (not (llvm:get-globalvar "CHANNELS"))
    (bind-val CHANNELS i64 *au:channels*))
(if (not (llvm:get-globalvar "IN_CHANNELS"))
    (bind-val IN_CHANNELS i64 *au:in-channels*))
(if (not (llvm:get-globalvar "FRAMES"))
    (bind-val FRAMES i64 *au:block-size*))

(bind-alias DSP [double,double,double,double,double*]*)

(bind-func print_audio_state
  (lambda ()
    (printf "    FRAMES: %lld\n" FRAMES)
    (printf " OUT CHANS: %lld\n" CHANNELS)
    (printf "  IN CHANS: %lld\n" IN_CHANNELS)
    (printf "SAMPLERATE: %f\n" SAMPLERATE)))

(print_audio_state)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; silence
(bind-func dsp:DSP
  (lambda (in time chan dat)
    0.0))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html

(bind-func dsp_randn
  (let ((phase 0))
    (lambda ()
      (let ((u1 (random))
	    (u2 (random))
	    (v1 (- (* 2.0 u1) 1.0))
	    (v2 (- (* 2.0 u2) 1.0))
	    (s (+ (* v1 v1) (* v2 v2))))
	(if (= phase 0)
	    (if (or (> s 1.0) (= s 0.0) (= s 1.0))
		(dsp_randn)
		(* v1 (sqrt (/ (* -2.0 (log s)) s))))
	    (begin (set! phase (- 1 phase))
		   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))

;; high limit
;; low limit
;; then value
(bind-func range_limit
  (lambda (h:double l:double v:double)
    (if (< v l) l
	(if (> v h) h
	    v))))

;; x values must fall within the range -PI ... PI
(bind-func _sin
  (let ((p 0.225) ; :_abuf* (alloc))
	(b (/ 4.0 PI))
	(c (/ -4.0 (* PI PI))))
    (lambda (x)
      (let ((y (+ (* b x) (* c x (fabs x)))))
	(+ (* p (- (* y (fabs y)) y)) y)))))

;; (bind-func osc_c
;;   (lambda (phase)
;;     (lambda (amp freq)
;;       (let ((inc (* TWOPI (/ freq SAMPLERATE))))
;; 	(set! phase (+ phase inc))
;; 	(* amp (sin phase))))))


(bind-func osc_c
  (lambda (phase)
    (lambda (amp freq)
      (let ((inc (* TWOPI (/ freq SAMPLERATE))))
	(set! phase (+ phase inc))
	(if (> phase PI) (set! phase (- phase TWOPI)))
	(* amp (_sin phase))))))


(if *build-multi-chan*
    (bind-func osc_mc_c
      (lambda (phase)
	(let ((mem 0.0)
	      (osc (osc_c phase)))
	  (lambda (chan amp freq)
	    (if (< chan 1.0) (set! mem (osc amp freq)))
	    mem)))))

;; square oscillator
;; where 'n' is how squared off the wave is
;; an n of 1.0 is very rounded
;; an n of 30.0 is very sharp
(bind-func square_c
  (lambda (phase)   
    (let ((osc (osc_c phase)))
      (lambda (amp freq n)
	(* amp (tanh (* n (osc 1.0 freq))))))))


;; square oscillator multichannel
(if *build-multi-chan*
    (bind-func square_mc_c
      (lambda (phase)   
	(let ((sqr (square_c phase))
	      (mem 0.0))
	  (lambda (chan amp freq n)	
	    (if (< chan 1.0) (set! mem (sqr amp freq n)))
	    mem)))))

;; a 'leaky' integrator
(bind-func integrator_c
  (let ((old 0.0)
        (leak 0.99))
    (lambda (x)
      (set! old (+ (* leak old) x))
      old)))

;; triangle oscillator
;; by using leak integrator over square
;; see square wave for 'n'
(bind-func triangle_c
  (lambda (phase)   
    (let ((osc (osc_c phase))	  
          (old 0.0)
          (new 0.0)
          (leak 0.9))
      (lambda (amp freq n)
	(set! old (+ (* leak old)
                     (* amp (tanh (* n (osc 1.0 freq))))))
        (* 0.125 old)))))

;; saw oscillator
(if *build-multi-chan*
    (bind-func triangle_mc_c
      (lambda (phase)
	(let ((mem 0.0)
	      (tri (triangle_c phase)))
	  (lambda (chan amp freq n)
	    (if (< chan 1.0) (set! mem (tri amp freq n)))
	    mem)))))

;; rect wave oscillator - useful for pulse width modulation
(bind-func rect_c
  (lambda (phase)
    (lambda (amp freq duty)
      (let ((inc (/ freq SAMPLERATE)))
	(set! phase (+ phase inc))
	(if (> phase 1.0) (set! phase (- phase 1.0)))
	(if (< phase duty) amp (* -1.0 amp))))))

;; saw oscillator
(bind-func saw_c
  (lambda (phase)
    (let ((dp 1.0)
	  (x 0.0)
	  (leak 0.995)
	  (saw 0.0))
      (lambda (amp freq)
	(let* ((qmax (* 0.5 (/ SAMPLERATE freq)))
	       (dc (/ -0.498 qmax)))
	  (set! phase (+ phase dp))
	  (if (< phase 0.0) 
	      (begin (set! phase (- 0.0 phase))
		     (set! dp (- 0.0 dp)))
	      (if (> phase qmax)
		  (begin (set! phase (+ qmax (- qmax phase)))
			 (set! dp (- 0.0 dp)))))
	  (set! x (* PI phase))
	  (if (< x 0.000001) (set! x 0.00001))
	  (set! saw (* leak (+ saw (+ dc (/ (sin x) x)))))
	  (* amp saw))))))


;; saw oscillator
(if *build-multi-chan*
    (bind-func saw_mc_c
      (lambda (phase)
	(let ((mem 0.0)
	      (saw (saw_c phase)))
	  (lambda (chan amp freq)
	    (if (< chan 1.0) (set! mem (saw amp freq)))
	    mem)))))

;; white noise generator
(bind-func white_c
  (lambda ()
    (lambda ()
      (* 0.33 (dsp_randn)))))

;; pink noise generator
;; uses Paul Kellet's economy method
;; http://www.firstpr.com.au/dsp/pink-noise/
(bind-func pink_c
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0))
      (lambda ()
        (set! b0 (+ (* b0 0.99765) (* (dsp_randn) 0.0555179)))
        (set! b1 (+ (* b1 0.96300) (* (dsp_randn) 0.2965164)))
        (set! b2 (+ (* b2 0.57000) (* (dsp_randn) 1.0526913)))
        (* 0.33 (+ b0 b1 b2 (* (dsp_randn) 0.1848)))))))

;; pulse train
(bind-func pulse_c
  (lambda ()
    (let ((time -1.0)
          (period 0.0))
      (lambda (amp:double freq width)
	(set! period (/ SAMPLERATE freq))
        (set! time (+ time 1.0))
        (if (< (modulo time period) width)
            amp
            0.0)))))

(if *build-multi-chan*
    (bind-func pulse_mc_c
      (lambda ()
	(let ((pulse (pulse_c))
	      (mem 0.0))
	  (lambda (chan amp freq width)
	    (if (< chan 1.0) (set! mem (pulse amp freq width)))
	    mem)))))


;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
(bind-func delay_old_c
  (lambda (max_delay)
    (let ((line:double* (zalloc max_delay))
	  (time 0)
	  (delay max_delay)
	  (in 1.0)
	  (out 0.5))
      (lambda (x:double)
	(let* ((n (modulo time delay))
	       (delayed (pref line n))
	       (y (+ (* in x) (* out delayed))))
	  (pset! line n y)
	  (set! time (+ time 1))
	  y)))))

;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
(bind-func delay_c 
  (lambda (max_delay)
    (let ((delay (dtoi64 max_delay))
          (line:double* (zalloc delay))
	  (time 0)
          (n 0)
          (y 0.0))
      (lambda (x:double wet feedback)
        (set! n (modulo time delay))
        (set! y (pref line n))
        (set! time (+ time 1))
        (pset! line n (* feedback (+ x y)))
        (+ x (* y wet))))))


(if *build-multi-chan*
    (bind-func delay_mc_c
      (lambda (channels:i64 max_delay)
	(let ((dlines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (delay_c max_delay)))
	  (lambda (chan x wet feedback)
	    ((pref dlines (dtoi32 chan)) x wet feedback))))))

;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
;;
;; offset is for metro 'get-mark offset
(bind-func delay_t_c 
  (lambda (max_delay offset)
    (let ((delay (dtoi64 max_delay))
          (line:double* (zalloc delay))
	  ;; (time 0)
          (n 0)
          (y 0.0))
      (lambda (x:double time wet feedback)
        (set! n (modulo (dtoi64 (- time offset)) delay))
        (set! y (pref line n))
        ;;(set! time (+ time 1))
        (pset! line n (* feedback (+ x y)))
        (+ x (* y wet))))))


(if *build-multi-chan*
    (bind-func delay_t_mc_c
      (lambda (channels:i64 max_delay offset)
	(let ((dlines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (delay_t_c max_delay offset)))
	  (lambda (chan x time wet feedback)
	    ((pref dlines (dtoi32 chan)) x time wet feedback))))))

(if *build-multi-chan*
    (bind-func delay_t_st_c
      (lambda (d1 d2 offset)
	(let ((dlines:[double,double,double,double,double]** (alloc 2))
	      (i:i64 0))
	  (pset! dlines 0 (delay_t_c d1 offset))
	  (pset! dlines 1 (delay_t_c d2 offset))
	  (lambda (chan x time wet feedback)
	    ((pref dlines (dtoi32 chan)) x time wet feedback))))))


;; iir comb with interpolation
(bind-func comb_old_c
  (lambda (max_delay)
    (let ((line:double* (zalloc max_delay))
	  (in_head 0)
	  (out_head 0)
	  (delay_ (i64tod max_delay))
	  ;;(delay (i64tod max_delay))
	  (alpha 0.0)
	  (om_alpha 1.0)
	  (in 1.0)
	  (i 0)
	  (out 0.5))
      (dotimes (i max_delay) (pset! line i 0.0))
      (lambda (x:double delay:double)
	(if (<> delay delay_)
	    (begin (set! delay_ delay)		 
		   (set! alpha (- delay (floor delay)))
		   (set! om_alpha (- 1.0 alpha))
		   (set! out_head (- (+ max_delay in_head)
				     (dtoi64 delay)))))
	(let* ((ih:i64 (modulo in_head max_delay))
	       (oh:i64 (modulo out_head max_delay))
	       (delayed1 (pref line oh))
	       (delayed2 (pref line (modulo (+ oh 1) max_delay)))
	       (delayed (+ (* alpha delayed1) (* om_alpha delayed2))) 
	       (y (+ (* in x) (* out delayed))))
	  (pset! line ih y)
	  (set! in_head (+ ih 1))
	  (set! out_head (+ oh 1))
	  y)))))


;; iir comb with interpolation
(bind-func comb_c
  (lambda (max_delay)    
    (let ((maxdelay (dtoi64 max_delay))
          (line:double* (zalloc maxdelay))
	  (in_head 0)
	  (out_head 0)
	  (delay_ max_delay)          
	  (alpha 0.0)
	  (om_alpha 1.0)
          (ih:i64 0)
          (oh:i64 0)
          (delayed1 0.0)
          (delayed2 0.0)
          (delayed 0.0))
      (dotimes (ih maxdelay) (pset! line ih 0.0))
      (lambda (x:double delay:double wet feedback)
	(if (<> delay delay_)
	    (begin (set! delay_ delay)		 
		   (set! alpha (- delay (floor delay)))
		   (set! om_alpha (- 1.0 alpha))
		   (set! out_head (- (+ maxdelay in_head)
				     (dtoi64 delay)))))
	(set! ih (modulo in_head maxdelay))
	(set! oh (modulo out_head maxdelay))
	(set! delayed1 (pref line oh))
	(set! delayed2 (pref line (modulo (+ oh 1) maxdelay)))
	(set! delayed (+ (* alpha delayed1) (* om_alpha delayed2)))
	;;(set! y (+ (* in x) (* out delayed)))
        (pset! line ih (* feedback (+ x delayed)))
        (set! in_head (+ ih 1))
        (set! out_head (+ oh 1))
        (+ x (* delayed wet))))))


(if *build-multi-chan*
    (bind-func comb_mc_c
      (lambda (channels:i64 max_delay)
	(let ((dlines:[double,double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (comb_c max_delay)))
	  (lambda (chan x delay wet feedback)
	    (let ((f (pref dlines (dtoi32 chan))))
	      (f x delay wet feedback)))))))


;; flanger
(bind-func flanger_c
  (lambda (delay mod_phase mod_range mod_rate)
    (let ((comb (comb_c (+ delay mod_range)))
	  (mod (osc_c mod_phase)))
      (lambda (x:double wet feedback)
	(comb x (+ delay (mod mod_range mod_rate)) wet feedback)))))


(if *build-multi-chan*
    (bind-func flanger_mc_c
      (lambda (channels:i64 delay mod_phase mod_range mod_rate)
	(let ((comb (comb_mc_c channels (+ delay mod_range)))
	      (mod (osc_mc_c mod_phase))
	      (i:i64 0))
	  (lambda (chan x wet feedback)
	    (comb chan x (+ delay (mod chan mod_range mod_rate)) wet feedback))))))

;; chorus
(bind-func chorus_c
  (lambda (phase)
    (let ((delay 700.0)
	  (range 200.0)
	  (rate 0.1)
	  (comb1 (comb_c (+ delay range)))
	  (comb2 (comb_c (+ delay range)))
	  (comb3 (comb_c (+ delay range)))
	  (mrng1 range)
	  (mrng2 (* (random) range))
	  (mrng3 (* (random) range))
	  (mrte1 rate)
	  (mrte2 (* rate 1.372))
	  (mrte3 (* rate 0.792))
	  (dly1 delay)
	  (dly2 (* (random) delay))
	  (dly3 (* (random) delay))
	  (mod1 (osc_c phase))
	  (mod2 (osc_c phase))
	  (mod3 (osc_c phase)))
      (lambda (x:double wet fb)
	(+ (comb1 x (+ dly1 (mod1 mrng1 mrte1) wet fb) wet fb)
	   (comb2 x (+ dly2 (mod2 mrng2 mrte2) wet fb) wet fb)
	   (comb3 x (+ dly3 (mod3 mrng3 mrte3) wet fb) wet fb))))))

(if *build-multi-chan*
    (bind-func chorus_mc_c
      (lambda (channels:i64 phase)
	(let ((dlines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (chorus_c phase)))
	  (lambda (chan x wet fb)
	    (let ((f (pref dlines (dtoi32 chan))))
	      (f x wet fb)))))))


;; tap delay
(bind-func tap_delay_c
  (lambda (max_delay num_of_taps)
    (let ((line:double* (zalloc max_delay))
	  (taps:i64* (zalloc num_of_taps))
	  (delay max_delay)
	  (time 0))
      (lambda (x:double)
	(let ((y 0.0)
	      (i 0)
	      (n (modulo time delay))
	      (gain (/ 1.0 (i64tod num_of_taps))))
	  (pset! line n x)
	  (dotimes (i num_of_taps)
	    (set! y (+ y (* gain (pref line (modulo (+ (pref taps i) n) delay))))))
	  (set! time (+ time 1))
	  y)))))

;; allpass
(bind-func allpass_old_c
  (lambda (delay)
    (let ((inline:double* (zalloc delay))
	  (outline:double* (zalloc delay))
	  (time 0)
	  (g 0.9))
      (lambda (x)
	(let* ((n (modulo time delay))
	       (dy (pref outline n))
	       (dx (pref inline n))
	       (y (+ (* -1.0 g x)
		     dx
		     (* g dy))))
	  (pset! inline n x)
	  (pset! outline n y)
	  (set! time (+ time 1))
	  y)))))

;; allpass
(bind-func allpass_c
  (lambda (delay)
    (let ((_delay (dtoi64 delay))
          (inline:double* (zalloc _delay))
	  (outline:double* (zalloc _delay))
	  (time 0))
      (lambda (x fb)
	(let* ((n (modulo time _delay))
	       (dy (pref outline n))
	       (dx (pref inline n))
	       (y (+ (* -1.0 fb x)
		     dx
		     (* fb dy))))
	  (pset! inline n x)
	  (pset! outline n y)
	  (set! time (+ time 1))
	  y)))))


(if *build-multi-chan*
    (bind-func allpass_mc_c
      (lambda (channels:i64 delay)
	(let ((lines:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (allpass_c delay)))
	  (lambda (chan x wet)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x wet)))))))


;; a dodgy reverb
;; (bind-func reverb_c
;;   (lambda (size) ; size in ms
;;     (let ((ms (/ SAMPLERATE 1000.0))
;; 	  (wet .25)
;; 	  (dly1 (delay_c (dtoi64 (* ms (* .192 size)))))
;; 	  (dly2 (delay_c (dtoi64 (* ms (* .373 size)))))
;; 	  (dly3 (delay_c (dtoi64 (* ms (* .671 size)))))
;; 	  (dly4 (delay_c (dtoi64 (* ms (* .712 size)))))
;; 	  (ap1 (allpass_c (dtoi64 (* ms size))))
;; 	  (ap2 (allpass_c (dtoi64 (* ms (* .329 size))))))
;;       (ap1.g .8)
;;       (ap2.g .8)
;;       (lambda (in)
;; 	(let ((wetin (* in wet)))
;; 	  (+ (* in (- 1.0 wet)) (ap1 (ap2 (+ (dly1 wetin)
;; 					     (dly2 wetin)
;; 					     (dly3 wetin)
;; 					     (dly4 wetin))))))))))

;; a dodgy reverb mk2
(bind-func reverb_old_c
  (lambda (size) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
	  (dly1 (delay_old_c (dtoi64 (* ms (* .192 size)))))
	  (dly2 (delay_old_c (dtoi64 (* ms (* .373 size)))))
	  (dly3 (delay_old_c (dtoi64 (* ms (* .671 size)))))
	  (dly4 (delay_old_c (dtoi64 (* ms (* .712 size)))))
	  (ap1 (allpass_old_c (dtoi64 (* ms size))))
	  (ap3 (allpass_old_c (dtoi64 (* ms (* .929 size)))))
	  (ap2 (allpass_old_c (dtoi64 (* ms (* .329 size))))))
      (ap1.g .8)
      (ap2.g .7)
      (ap3.g .6)
      (lambda (in wet)
	(let ((wetin (* in wet)))
	  (+ (* in (- 1.0 wet))
	     (ap1 (ap2 (ap3 (+ (dly1 wetin)
			       (dly2 wetin)
			       (dly3 wetin)
			       (dly4 wetin)))))))))))


;; a dodgy reverb mk2
(bind-func reverb_c
  (lambda (size) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
	  (dly1 (delay_c (* ms (* .192 size))))
	  (dly2 (delay_c (* ms (* .373 size))))
	  (dly3 (delay_c (* ms (* .671 size))))
	  (dly4 (delay_c (* ms (* .712 size))))
	  (ap1 (allpass_c (* ms size)))
	  (ap3 (allpass_c (* ms (* .929 size))))
	  (ap2 (allpass_c (* ms (* .329 size)))))
      (lambda (in wet fb)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 (* .3 (+ (dly1 wetin 1.0 fb)
                                     (dly2 wetin 1.0 fb)
                                     (dly3 wetin 1.0 fb)
                                     (dly4 wetin 1.0 fb)))
                            .8)
                       .7)
                  .6)))))))

(if *build-multi-chan*
    (bind-func reverb_mc_c
      (lambda (channels:i64 size)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (reverb_c size)))
	  (lambda (chan x wet fb)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x wet fb)))))))


;; a dodgy reverb mk2
(bind-func reverb2_c
  (lambda (size) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
	  (ap1 (allpass_c (* ms size)))
	  (ap3 (allpass_c (* ms (* .929 size))))
	  (ap2 (allpass_c (* ms (* .329 size)))))
      (lambda (in wet)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 wetin .8) .7) .6)))))))


(if *build-multi-chan*
    (bind-func reverb2_mc_c
      (lambda (channels:i64 size)
	(let ((lines:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (reverb2_c size)))
	  (lambda (chan x wet)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x wet)))))))




;; a dodgy bitcrusher
(bind-func crusher_c
  (lambda ()
    (let ((amp 1.0))
      (lambda (in bits)
	(* amp (/ (floor (* in (pow 2. bits))) 
		  (pow 2. bits)))))))

;; if h is greater than 0.0
;; the continue to play last
;; held sample
(bind-func hold3_c
  (lambda ()
    (let ((mem 0.0))
      (lambda (in h:double)
        (if (> h 0.0)
            mem
            (begin (set! mem in)
                   in))))))


(if *build-multi-chan*
    (bind-func hold_mc_c
      (lambda (channels:i64)
	(let ((holds:[double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! holds i (hold3_c)))
	  (lambda (chan x h)
	    (let ((f (pref holds (dtoi32 chan))))
	      (f x h)))))))


;; a dodgy bitcrusher
(bind-func crush
  (lambda (in bits)
    (/ (floor (* in (pow 2. bits))) 
       (pow 2. bits))))


;; a dodgy amp distortion
(bind-func distort_c
  (lambda (gain)
    (let ((lim 0.5))
      (lambda (in)
	(range_limit lim (* -1.0 lim) (* gain in))))))

;; mono in (ignores anything in on channel 2)
;; pan value [0.0-1.0]
(bind-func pan2
  (let ((out 0.0))
    (lambda (x:double chan pan)
      (if (< chan 0.5)
          (begin (set! out x) (* (- 1.0 pan) out))
          (* pan out)))))

;; mono in (ignores all other channels)
;; pan value [0.0-1.0]
(if *build-multi-chan*
    (bind-func pan_mc
      (lambda (channels)
        (let ((v:double 0.0)
              (out:double 0.0))
          (lambda (x:double chan pan)
            (if (< chan 0.5) (set! out x))
            (set! v (fabs (- (* (- channels 1.0) pan) chan)))
            (if (> v 1.0) 0.0
                (* (- 1.0 v) out)))))))


;; simple stereo weights
(bind-func mix2
  (lambda (x:double chan left right)
    (cond ((< chan 0.5) (* x left))
          ((< chan 1.5) (* x right))
          (else 0.0))))            

;; simple quad weights
(bind-func mix4
  (lambda (x:double chan c1 c2 c3 c4)
    (cond ((< chan 0.5) (* x c1))
	  ((< chan 1.5) (* x c2))
	  ((< chan 2.5) (* x c3))
	  ((< chan 3.5) (* x c4))
	  (else 0.0))))

;; a four channel mixer
;; cdat is an array of doubles values
;; each array element is a channels mix (between 0.0 and 1.0)
(bind-func mixer_c
  (lambda (channels:i64)
    (let ((ch (i64tod channels)))
      (lambda (cdat:double* chan:double in:double)
	(if (< chan channels)
	    (* in (pref cdat (dtoi32 chan)))
	    0.0)))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; BiQuad coefficient formulae from 
;; Audio EQ Cookbook Robert Bristow-Johnson
;;
;; http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; biquad low-pass filter
(bind-func lpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (oldres 0.0)
	   (oldfreq 0.0))
      (lambda (x freq res)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> freq oldfreq)
		(<> res oldres))
	    (let* ((omega (* TWOPI (/ freq SAMPLERATE)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (/ sino (* 2.0 res))))
	      (set! oldfreq freq)
	      (set! oldres res)
	      (set! b0 (/ (- 1.0 coso) 2.0))
	      (set! b1 (- 1.0 coso))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((y (- (+ (* (/ b0 a0) x)
		       (* (/ b1 a0) x1)
		       (* (/ b2 a0) x2))
		    (* (/ a1 a0) y1)
		    (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 y)
	  (set! x2 x1)
	  (set! x1 x)
	  y)))))

(if *build-multi-chan*
    (bind-func lpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (lpf_c)))
	  (lambda (chan x freq res)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x freq res)))))))


;; biquad high-pass filter
(bind-func hpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (oldres 0.0)
	   (oldfreq 0.0))
      (lambda (x freq res)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> freq oldfreq)
		(<> res oldres))
	    (let* ((omega (* TWOPI (/ freq SAMPLERATE)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (/ sino (* 2.0 res))))
	      (set! oldfreq freq)
	      (set! oldres res)
	      (set! b0 (/ (+ 1.0 coso) 2.0))
	      (set! b1 (* -1.0 (+ 1.0 coso)))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((y (- (+ (* (/ b0 a0) x)
		       (* (/ b1 a0) x1)
		       (* (/ b2 a0) x2))
		    (* (/ a1 a0) y1)
		    (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 y)
	  (set! x2 x1)
	  (set! x1 x)
	  y)))))

(if *build-multi-chan*
    (bind-func hpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (hpf_c)))
	  (lambda (chan x freq res)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x freq res)))))))


;; biquad band-pass filter
(bind-func bpf_c
  (lambda () 
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (oldfreq 0.0)
	   (oldbw 0.0))
      ;; bandwidth in octaves
      (lambda (x freq bandwidth)
	;; if frequency or bandwidth change
	;; recalculate coefficients
	(if (or (<> freq oldfreq)
		(<> bandwidth oldbw))
	    (let* ((omega (* 1.0 TWOPI (/ freq SAMPLERATE)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (* (/ (log2 2.0) 2.0)
					   bandwidth
					   (/ omega sino))))))
	      (set! oldfreq freq)
	      (set! oldbw bandwidth)
	      (set! b0 alpha)
	      (set! b1 0.0) 
	      (set! b2 (* -1.0 b0))
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((y (- (+ (* (/ b0 a0) x)
		       (* (/ b1 a0) x1)
		       (* (/ b2 a0) x2))
		    (* (/ a1 a0) y1)
		    (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 y)
	  (set! x2 x1)
	  (set! x1 x)
	  y)))))


(if *build-multi-chan*
    (bind-func bpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (bpf_c)))
	  (lambda (chan x freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x freq bandwidth)))))))


;; biquad notch filter
(bind-func notch_c
  (lambda () 
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)	     
	   (oldfreq 0.0)
	   (oldbw 0.0))
      ;; bandwidth in octaves
      (lambda (x freq bandwidth)
	;; if frequency or bandwidth change
	;; recalculate coefficients
	(if (or (<> freq oldfreq)
		(<> bandwidth oldbw))
	    (let* ((omega (* TWOPI (/ freq SAMPLERATE)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (* (/ (log2 2.0) 2.0)
					   bandwidth
					   (/ omega sino))))))
	      (set! oldfreq freq)
	      (set! oldbw bandwidth)
	      (set! b0 1.0)
	      (set! b1 (* -2.0 coso)) 
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 b1)
	      (set! a2 (- 1.0 alpha))))
	(let ((y (- (+ (* (/ b0 a0) x)
		       (* (/ b1 a0) x1)
		       (* (/ b2 a0) x2))
		    (* (/ a1 a0) y1)
		    (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 y)
	  (set! x2 x1)
	  (set! x1 x)
	  y)))))

(if *build-multi-chan*
    (bind-func notch_mc_c
      (lambda (channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (notch_c)))
	  (lambda (chan x freq bandwidth)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x freq bandwidth)))))))

;; Hilbert transform filter

(bind-func hilbert_c
  "n = filter order (should be 2^n + 1)"
  (lambda (n)
    (let ((i 0)
          (h_n:double* (alloc n))
          (x_n:double* (alloc n))
          (x_ptr 0))
      ;; h[i] = (2/(i*pi))*sin^2((i*pi)/2) for i=-n/2,...,n/2
      (dotimes (i n (/ (* n -1) 2))
        (pset! h_n
               (+ i (/ n 2))
               (* (/ 2.0 (* (i64tod i) PI))
                  (pow (sin (/ (* (i64tod i) PI) 2.0)) 2.0))))
      ;; h[0] = 0
      (pset! h_n (+ 1 (/ n 2)) 0.0)
      (lambda (x)
        (pset! x_n x_ptr x)
        (let ((out 0.0))
          (dotimes (i n)
            (set! out (+ out (* (pref h_n i)
                                (pref x_n (modulo (+ i x_ptr (- n 1)) n))))))
          (modulo (set! x_ptr (+ x_ptr 1)) n)
          out)))))

(bind-func env_follow_c
  (lambda (n)
    (let ((hilb (hilbert_c n)))
      (lambda (x)
        (sqrt (+ (pow x 2.0)
                 (pow (hilb x) 2.0)))))))

;;
;; moog VCF
;;
;; from Stilson/Smith CCRMA
;;
(bind-func vcf_old_c
  (lambda ()
    (let ((x 0.0) (y1 0.0) (y2 0.0) (y3 0.0) (y4 0.0)
	  (oldx 0.0) (oldy1 0.0) (oldy2 0.0) (oldy3 0.0))
      (lambda (in cutoff res)
	(let ((f (* 1.75 (/ cutoff SAMPLERATE)))
              ;;(k (- (* 2.0 (sin (* f (/ PI 2.0)))) 1.0))
	      (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
	      (p (* 0.5 (+ k 1.0)))
	      (scale (exp (* (- 1.0 p) 1.386249)))
	      (r (* res scale)))
	  (set! x (- in (* r y4)))
	  (set! y1 (+ (* x  p) (* oldx  p) (* -1.0 k y1)))
	  (set! y2 (+ (* y1 p) (* oldy1 p) (* -1.0 k y2)))
	  (set! y3 (+ (* y2 p) (* oldy2 p) (* -1.0 k y3)))
	  (set! y4 (+ (* y3 p) (* oldy3 p) (* -1.0 k y4)))

	  (set! oldx x) (set! oldy1 y1) (set! oldy2 y2) (set! oldy3 y3)
	  ;; y4 is output
	  (set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping
	  y4)))))


;;
;; moog VCF variation 1
;;
;; from Stilson/Smith CCRMA
;;
(bind-func vcf1_c
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0) (b3 0.0) (b4 0.0)
	  (t1 0.0) (t2 0.0) (t3 0.0))
      (lambda (in cutoff res)
	(let ((frq (* 1.75 (/ cutoff SAMPLERATE)))
              (q (- 1.0 frq))
	      (p (+ frq (* 0.8 frq q)))
              (f (+ p (- p 1.0))))
          (set! q (* res (+ 1.0 (* 0.5 q (+ (- 1.0 q) (* 5.6 q q))))))          
	  (set! in (- in (* q b4))) ;; feedback
          (set! t1 b1) (set! b1 (- (* (+ in b0) p) (* b1 f)))
          (set! t2 b2) (set! b2 (- (* (+ b1 t1) p) (* b2 f)))
          (set! t1 b3) (set! b3 (- (* (+ b2 t2) p) (* b3 f)))
                       (set! b4 (- (* (+ b3 t1) p) (* b4 f)))
          (set! b4 (- b4 (* b4 b4 b4 0.166667))) ;; clipping
          (set! b0 in)
          b4)))))

;;
;; moog VCF variation 2
;;
;; from Stilson/Smith CCRMA
;;
;; type is:
;; lp 1 (or anything)
;; hp 2
;; bp 3
(bind-func vcf_c
  (lambda (type)
    (let ((x 0.0) (y1 0.0) (y2 0.0) (y3 0.0) (y4 0.0)
	  (oldx 0.0) (oldy1 0.0) (oldy2 0.0) (oldy3 0.0))
      (lambda (in cutoff res)
	(let ((f (* 1.75 (/ cutoff SAMPLERATE)))
              ;;(k (- (* 2.0 (sin (* f (/ PI 2.0)))) 1.0))
	      (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
	      (p (* 0.5 (+ k 1.0)))
	      (scale (exp (* (- 1.0 p) 1.386249)))
	      (r (* res scale)))
	  (set! x (- in (* r y4)))
	  (set! y1 (+ (* x  p) (* oldx  p) (* -1.0 k y1)))
	  (set! y2 (+ (* y1 p) (* oldy1 p) (* -1.0 k y2)))
	  (set! y3 (+ (* y2 p) (* oldy2 p) (* -1.0 k y3)))
	  (set! y4 (+ (* y3 p) (* oldy3 p) (* -1.0 k y4)))

	  (set! oldx x) (set! oldy1 y1) (set! oldy2 y2) (set! oldy3 y3)
	  ;; y4 is output
	  (set! y4 (- y4 (* y4 y4 y4 0.1666667))) ;; clipping
	  ;;(set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping          
	  (if (= 2 type) (- x y4)
              (if (= 3 type) (* 3.0 (- y3 y4))
                  y4)))))))


;;
;; moog VCF variation 3
;;
;; from Stilson/Smith CCRMA
;;
;; type is:
;; lp 1 (or anything)
;; hp 2
;; bp 3
(bind-func vcf3_c
  (lambda (type)
    (let ((b0 0.0) (b1 0.0) (b2 0.0) (b3 0.0) (b4 0.0)
	  (t1 0.0) (t2 0.0) (t3 0.0))
      (lambda (in cutoff res)
	(let ((frq (* 1.75 (/ cutoff SAMPLERATE)))
              (q (- 1.0 frq))
	      (p (+ frq (* 0.8 frq q)))
              (f (+ p (- p 1.0))))
          (set! q (* res (+ 1.0 (* 0.5 q (+ (- 1.0 q) (* 5.6 q q))))))          
	  (set! in (- in (* q b4))) ;; feedback
          (set! t1 b1) (set! b1 (- (* (+ in b0) p) (* b1 f)))
          (set! t2 b2) (set! b2 (- (* (+ b1 t1) p) (* b2 f)))
          (set! t1 b3) (set! b3 (- (* (+ b2 t2) p) (* b3 f)))
                       (set! b4 (- (* (+ b3 t1) p) (* b4 f)))
          (set! b4 (- b4 (* b4 b4 b4 0.166667)))
          ;;(set! b4 (- b4 (* b4 b4 0.25))) ;; clipping
          (set! b0 in)
          (if (= type 2) (- b0 b4) ;; high pass
              (if (= type 3) (* 3.0 (- b3 b4))
                  b4)))))))


(if *build-multi-chan*
    (bind-func vcf_mc_c
      (lambda (type:i64 channels:i64)
	(let ((lines:[double,double,double,double]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (vcf_c type)))
	  (lambda (chan x freq res)
	    (let ((f (pref lines (dtoi32 chan))))
	      (f x freq res)))))))

;; State Variable Filter adapted from
;; http://www.musicdsp.org/archive.php?classid=3#142 (it is possible
;; to get all the hp, lp, bp and notch output values in one function,
;; however they are currently provided in separate functions)

(if (not (llvm:get-globalvar "SVF_LOWPASS"))
    (bind-val SVF_LOWPASS i64 1))
(if (not (llvm:get-globalvar "SVF_HIGHPASS"))
    (bind-val SVF_HIGHPASS i64 2))
(if (not (llvm:get-globalvar "SVF_BANDPASS"))
    (bind-val SVF_BANDPASS i64 3))
(if (not (llvm:get-globalvar "SVF_NOTCH"))
    (bind-val SVF_NOTCH i64 4))
(if (not (llvm:get-globalvar "SVF_PEAK"))
    (bind-val SVF_PEAK i64 5))

(bind-func min2d
  (lambda (a:double b)
    (if (< a b) a b)))

(bind-func svf_c
  "Returns a (state variable) filter closure"
  (lambda (type)
    ;; old values
    (let ((cutoff_ 0.0)
          (resonance_ 0.0)
          (drive 0.0)
          (freq 0.0)
          (damp 0.0)
          (notch 0.0)
          (low 0.0)
          (high 0.0)
          (band 0.0)
          (peak 0.0)
          (out 0.0))
      (lambda (in cutoff resonance)
        ;; recalculate some values if cutoff or resonance have changed
        (if (or (<> cutoff cutoff_)
                (<> resonance resonance_))
            (begin
              (set! cutoff_ cutoff)
              (set! resonance_ resonance)
              (set! freq (* 2.0 (sin (* PI (min2d 0.25 (/ cutoff (* SAMPLERATE 2.0)))))))
              (set! damp (min2d (* 2.0 (- 1.0 (pow resonance 0.25)))
                                (min2d 2.0 (- (/ 2.0 freq) (* freq 0.5)))))))
        (set! notch (- in (* damp band)))
        (set! low (+ low (* freq band)))
        (set! high (- notch low))
        (set! band (- (+ (* freq high) band)
                      (* drive band band band)))
        ;; this is a bit filthy - needs a macro
        (set! out (* 0.5 (if (= type SVF_LOWPASS)
                             low
                             (if (= type SVF_HIGHPASS)
                                 high
                                 (if (= type SVF_BANDPASS)
                                     band
                                     (if (= type SVF_NOTCH)
                                         notch
                                         (if (= type SVF_PEAK)
                                             peak
                                             0.0)))))))
        ;; now do it all again (because it's oversampled for
        ;; stability)
        (set! notch (- in (* damp band)))
        (set! low (+ low (* freq band)))
        (set! high (- notch low))
        (set! band (- (+ (* freq high) band)
                      (* drive band band band)))
        ;; this is a bit filthy - needs a macro
        (set! out (+ out (* 0.5 (if (= type SVF_LOWPASS)
                                    low
                                    (if (= type SVF_HIGHPASS)
                                        high
                                        (if (= type SVF_BANDPASS)
                                            band
                                            (if (= type SVF_NOTCH)
                                                notch
                                                (if (= type SVF_PEAK)
                                                    peak
                                                    0.0))))))))))))

;; based on Steve Harris's foverdrive lv2 plugin
;; http://plugin.org.uk/

(bind-func overdrive_c
  "Drive range:[1.0,3.0]"
  (lambda (drive)
    (let ((drive_minus_1 (- drive 1.0)))
      (lambda (x)
        (let ((absx (fabs x)))
          (/ (* x (+ absx drive))
             (+ (* x x)
                (* drive_minus_1 absx)
                1.0)))))))

;; based on Steve Harris's Valve Saturation lv2 plugin
;; http://plugin.org.uk/

(bind-func saturation_c
  "level:[0.0,1.0] character:[0.0,1.0]"
  (lambda ()
    (let ((itm1 0.0)
          (otm1 0.0))
      (lambda (x level character)
        (let ((q (- level 0.999))
              (dist (+ (* character 40.0) 0.1))
              (fx (if (= x q)
                      (/ (/ 1.0 (+ dist q))
                         (- 1.0 (exp (* dist q))))
                      (/ (/ (- x q)
                            (+ (- 1.0 (exp (* -1.0 dist (- x q)))) q))
                         (- 1.0 (exp (* dist q)))))))
          (set! otm1 (- (+ (* 0.999 otm1) fx) itm1))
          (set! itm1 fx)
          otm1)))))

(bind-func ringmod_c
  "freq feedback:[0.0,1.0]"
  (lambda ()
    (let ((osc (osc_c 0.0)))
      (lambda (x freq feedback)
        (+ (* (- 1.0 feedback) x)
           (* feedback (* x (osc freq 1.0))))))))

(bind-func hann_c
  "window of width samples - repeating every repeat samples"
  (lambda ()
    (let ((cnt -1.0))
      (lambda (width)
        (set! cnt (+ cnt 1.0))
        (* 0.5
           (- 1.0
              (cos (/ (* TWOPI (% cnt width))
                      (- width 1.0)))))))))

;; hann
(if *build-multi-chan*
    (bind-func hann_mc_c
      (lambda ()   
	(let ((h (hann_c))
	      (mem 0.0))
	  (lambda (chan width)	
	    (if (< chan 0.5) (set! mem (h width)))
	    mem)))))


(bind-func hann_t_c
  "window of width samples - repeating every repeat samples"
  (lambda (offset)
    (lambda (time width)      
      ;;(set! cnt (+ cnt 1.0))
      (* 0.5
         (- 1.0
            (cos (/ (* TWOPI (% (- time offset) width))
                    (- width 1.0))))))))

;; hann with time
(if *build-multi-chan*
    (bind-func hann_t_mc_c
      (lambda (offset)   
	(let ((h (hann_t_c offset))
	      (mem 0.0))
	  (lambda (chan time width)	
	    (if (< chan 0.5) (set! mem (h time width)))
	    mem)))))


(bind-func hann_e_c
  "window of 'width' samples, repeating every 'repeat' samples
   with an offset of 'offset' samples"
  (lambda ()
    (let ((cnt -1.0))
      (lambda (width offset repeat)
        (if (> cnt repeat) (set! cnt -1.0))        
        (set! cnt (+ cnt 1.0))
        (if (and (or (> cnt offset) (< offset 0.1))
                 (< cnt (+ width offset)))
            (* 0.5
               (- 1.0
                  (cos (/ (* TWOPI (% (- cnt offset) width))
                          (- width 1.0)))))
            0.0)))))
 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; envelope stuff
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; a repeating hann signal of width
(bind-func hann
  (lambda (time:double width:double repeat:double)
    (* 0.5
       (- 1.0
          (cos (/ (* TWOPI (% time repeat))
                  (- width 1.0)))))))

;; time in samples (starting from 0)
;; apex (in samples) is after how many samples we hit 1.0 before decaying
(bind-func impulse
  (lambda (time:double apex:double)
    (let ((h (* time apex)))
      (* h (exp (- 1.0 h))))))

(bind-func linear_c
  (let ((time 0.0))
    (lambda (start:double end:double dur:double)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (inc)
          (set! time (+ time inc))
          (+ (* m time) c))))))

(bind-func linear_mc_c
  (let ((time 0.0))
    (lambda (start:double end:double dur:double)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (chan inc)
          (if (< chan 0.5)
              (set! time (+ time inc)))
          (+ (* m time) c))))))

(bind-func line_c
  (lambda (x1:double y1:double x2 y2)
    (let* ((m (if (= 0.0 (- x2 x1)) 
		  0.0 
		  (/ (- y2 y1) (- x2 x1))))
	   (c (- y2 (* m x2))))
      (lambda (time) (+ (* m time) c)))))

(bind-func envelope_segments
  (lambda (points:double* num_of_points:i64)
    (let ((lines:[double,double]** (zalloc num_of_points))
	  (k 0))
      (dotimes (k num_of_points)
	(let* ((idx (* k 2))
	       (x1 (pref points (+ idx 0)))
	       (y1 (pref points (+ idx 1)))
	       (x2 (pref points (+ idx 2)))
	       (y2 (pref points (+ idx 3))))
	  (pset! lines k (line_c x1 y1 x2 y2))))
      lines)))

(bind-func envelope_c
  (lambda (points:double* num_of_points)
    (let ((klines:[double,double]** (envelope_segments points num_of_points))
	  (line_length num_of_points))
      (lambda (time)
	(let ((res -1.0)
	      (k:i64 0))
	  (dotimes (k num_of_points)
	    (let ((line (pref klines k))
		  (time_point (pref points (* k 2))))
	      (if (or (= time time_point)
		      (< time_point time))
		  (set! res (line time)))))
	  res)))))

;; make a convenience wrapper for asr
(bind-func adsr_c
  (lambda (start_time atk_dur dky_dur sus_dur rel_dur peak_amp sus_amp)
    (let* ((points 6)
	   (data:double* (zalloc (* points 2))))
      (pset! data 0 start_time)
      (pset! data 1 0.0)
      (pset! data 2 (+ start_time atk_dur)) ;; point data
      (pset! data 3 peak_amp)
      (pset! data 4 (+ start_time atk_dur dky_dur))
      (pset! data 5 sus_amp)
      (pset! data 6 (+ start_time atk_dur dky_dur sus_dur))
      (pset! data 7 sus_amp)
      (pset! data 8 (+ start_time atk_dur dky_dur sus_dur rel_dur))
      (pset! data 9 0.0)
      (pset! data 10 (+ start_time atk_dur dky_dur sus_dur rel_dur 1.0)) ;; this to flatten out at 0.0
      (pset! data 11 0.0)
      (let ((f (envelope_c data points)))
	(lambda (time:double)
	  (f time))))))


;; an accumulative adsr (random access not allowed! time must be linear).
(bind-func adsr_accum_c
  (lambda (start_time:double atk_dur dky_dur sus_dur rel_dur peak_amp sus_amp)
    (let ((val (if (> (+ atk_dur dky_dur) 1.0) 0.0 peak_amp))
	  (t1 atk_dur)
	  (t2 (+ atk_dur dky_dur))
	  (t3 (+ atk_dur dky_dur sus_dur))
	  (t4 (+ atk_dur dky_dur sus_dur rel_dur))	  
	  (inc1 (/ peak_amp atk_dur))
	  (inc2 (* -1.0 (/ (- peak_amp sus_amp) dky_dur)))
	  (inc3 (* -1.0 (/ sus_amp rel_dur))))
      (lambda (time:double chan)
	(if (< chan 1.0)
	    (cond ((> time t4) (set! val 0.0))
		  ((> time t3) (set! val (+ val inc3)))
		  ((> time t2) val) ;; sustain (don't do anything with val)
		  ((> time t1) (set! val (+ val inc2)))
		  ((> time 0) (set! val (+ val inc1)))
		  (else (set! val 0.0))))
	val))))

(bind-func hermite_interp
  (lambda (fractional y1:double x0 x1 x2)
    (let ((c (* 0.5 (- x1 y1)))
	  (v (- x0 x1))
	  (w (+ c v))
	  (a (+ w v (* (- x2 x0) 0.5)))
	  (b (+ w a)))
      (+ (* (+ (* (- (* a fractional) b) fractional) c) fractional) x0))))

;; linear fade closure
(bind-func fade_c
  (lambda (phase)
    (lambda (amp freq)
      (let ((inc (/ freq SAMPLERATE)))
	(if (> phase 1.0)
            amp
            (begin (set! phase (+ phase inc))
                   (* phase amp)))))))

;;  midi/freq utilities

(bind-func midi2frq    
  (lambda (pitch)            
    (* 440.0 (pow 2.0 (/ (- pitch 69.0) 12.0)))))

(bind-func frq2midi
  (lambda (freq)            
    (+ (* 12.0 (log2 (/ freq 440.0))) 69.0)))
