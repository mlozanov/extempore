;;; shaders.xtm -- GL shaders

;; Author: Andrew Sorensen
;; Keywords: extempore
;; Required dylibs: openGL

;;; Commentary:

;; 

;;; Code:

;; lib-loading config
(sys:load-preload-check 'shaders)
(sys:load "libs/external/opengl.xtm")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; GLOBAL to let other libraries know that
;; math.xtm has already been loaded
;; 
(define *xtmlib-shaders-loaded* #t)

;; draw a quad
;; tw and th are framebuffer width and height
(bind-func gl_draw_shader_quad
  (lambda (x y w h r tw th)
    (let ((hx (* -0.5 w))
	  (hy (* -0.5 h))
	  (xx (+ x (* .5 w)))
	  (yy (+ y (* .5 h))))
      (glPushMatrix)
      (glTranslated xx yy 0.0)
      (glRotated r 0.0 0.0 1.0)
      (glBegin GL_QUADS)
      (glTexCoord2d 0.0 0.0)
      (glVertex2d hx hy)
      (glTexCoord2d 0.0 th)
      (glVertex2d hx (+ hy h))
      (glTexCoord2d tw th)
      (glVertex2d (+ hx w) (+ hy h))
      (glTexCoord2d tw 0.0)
      (glVertex2d (+ hx w) hy)
      (glTexCoord2d 0.0 0.0)
      (glEnd)
      (glPopMatrix)
      void)))


;; matrix should be float* 5x5
(bind-func shader_set_grid_offsets
  (lambda (matrix:float* width:float height:float factor:float)
    (let ((xinc:float (/ factor width))
	  (yinc:float (/ factor height))
	  (i 0) (j 0))
      (dotimes (i 5) ;; columns
	(dotimes (j 5) ;; rows
	  (pset! matrix (+ (* (+ (* i 5) j) 2) 0)
		 (+ (* -2.0 xinc)
		    (* (i32tof i) xinc)))
	  (pset! matrix (+ (* (+ (* i 5) j) 2) 1)
		 (+ (* -2.0 xinc)
		    (* (i32tof i) yinc)))))
      void)))


;; matrix should be float* 5x5
(bind-func shader_setup_convolution_filter
  (lambda (matrix:float* shader offset)
    (shader_set_grid_offsets matrix 1.0 1.0 offset) ;(* 2.0 (dtof (cos (* 2222.2 (i64tod (now)))))))
    (glUniform2fv (glGetUniformLocation shader "texoffset") 25 matrix)
    (glUniform1i (glGetUniformLocation shader "tex1") 0)))


(bind-func shader_update_camera
  (lambda (shader:i32 position target)
    (let ((direction:float* (salloc 8))
          (tmp:float* (pref-ptr direction 4)))
      (vsub position target 3 tmp)
      (vnorm tmp 3 direction)
      (pset! direction 3 0.0)
      (glUniform4fv (glGetUniformLocation shader "CameraPos") 1 position)
      (glUniform4fv (glGetUniformLocation shader "CameraDir") 1 direction)
      void)))

(bind-func shader_update_light
  (lambda (shader:i32 position target angle power:float ambient diffuse specular)
    ;(vprint position 4)
    ;(vprint target 4)
    (glUniform1f (glGetUniformLocation shader "ConstantAttenuation") 1.0)
    (glUniform1f (glGetUniformLocation shader "LinearAttenuation") 0.0)
    (glUniform1f (glGetUniformLocation shader "QuadraticAttenuation") 0.0)
    (glUniform1f (glGetUniformLocation shader "SpotExponent") power)
    (glUniform1f (glGetUniformLocation shader "SpotAngle") (- 1.0 (/ angle 180.0)))
    (glUniform4fv (glGetUniformLocation shader "LightPos") 1 position)
    (glUniform4fv (glGetUniformLocation shader "LightAmbient") 1 ambient)
    (glUniform4fv (glGetUniformLocation shader "LightSpecular") 1 specular)
    (glUniform4fv (glGetUniformLocation shader "LightDiffuse") 1 diffuse)
    (let ((direction:float* (salloc 4))
          (tmp:float* (salloc 4)))
      (vsub target position 3 tmp)
      (vnorm tmp 3 direction)
      (pset! direction 3 0.0)
      (glUniform4fv (glGetUniformLocation shader "SpotDir") 1 direction))
    void))

(bind-func shader_update_lights
  (let ((i:i32 0)
        (ca:float* (alloc 10)) ;; contant attenuation
        (la:float* (alloc 10)) ;; linear attenuation
        (qa:float* (alloc 10)) ;; quadratic attenuation
        (sa:float* (alloc 10)) ;; spot angle
        (dir:float* (alloc (* 10 4))) ;; spot dir
        (tmp:float* (alloc (* 10 4))))
    (dotimes (i 10)
      (pset! ca i 1.0) (pset! la i 0.0) (pset! qa i 0.0))
    (lambda (shader:i32 numlights:i32 position target angle:float* power ambient diffuse specular)
      (dotimes (i numlights) (pset! sa i (- 1.0 (/ (pref angle i) 180.0))))
      (glUniform1f (glGetUniformLocation shader "numlights") (i32tof numlights))
      (glUniform1fv (glGetUniformLocation shader "ConstantAttenuation") numlights ca)
      (glUniform1fv (glGetUniformLocation shader "LinearAttenuation") numlights la)
      (glUniform1fv (glGetUniformLocation shader "QuadraticAttenuation") numlights qa)
      (glUniform1fv (glGetUniformLocation shader "SpotExponent") numlights power)
      (glUniform1fv (glGetUniformLocation shader "SpotAngle") numlights sa)
      (glUniform4fv (glGetUniformLocation shader "LightPos") numlights position)
      (glUniform4fv (glGetUniformLocation shader "LightAmbient") numlights ambient)
      (glUniform4fv (glGetUniformLocation shader "LightSpecular") numlights specular)
      (glUniform4fv (glGetUniformLocation shader "LightDiffuse") numlights diffuse)
      (dotimes (i numlights)
        (vsub (pref-ptr target (* i 4))
              (pref-ptr position (* i 4))
              3
              (pref-ptr tmp (* i 4)))
        (vnorm (pref-ptr tmp (* i 4))
               3
               (pref-ptr dir (* i 4)))
        (pset! (pref-ptr dir (* i 4)) 3 0.0))
      (glUniform4fv (glGetUniformLocation shader "SpotDir") numlights dir)
      void)))


;; when working with OpenGL
;; extempore's mmul is pre mutipled (not post as in GLSL)
;; so the same matrix mul is post in GLSL and pre in XTM (i.e. here!)
(bind-func shader_update_matrices
  (lambda (id:i32 m v p)
    (let ((mv (salloc 48))
          (mvp (pref-ptr mv 16))
          (mn (pref-ptr mv 32)))
      (mmul m 4 4 v 4 4 mv) ;; final mv set
      (mtrans mv 4 4 mn) ;; using mn as a temporary here!!
      (minv mn 4 mvp) ;; using mvp as a temporary      
      (mat4_to_mat3 mvp mn)  ;; final mn set
      (mmul mv 4 4 p 4 4 mvp) ;; final mvp set
      (glUniformMatrix4fv (glGetUniformLocation id "ModelMatrix") 1 GL_FALSE m)
      (glUniformMatrix4fv (glGetUniformLocation id "ViewMatrix") 1 GL_FALSE v)
      (glUniformMatrix4fv (glGetUniformLocation id "ProjectionMatrix") 1 GL_FALSE p)
      (glUniformMatrix3fv (glGetUniformLocation id "NormalMatrix") 1 GL_FALSE mn)      
      (glUniformMatrix4fv (glGetUniformLocation id "ModelViewMatrix") 1 GL_FALSE mv)
      (glUniformMatrix4fv (glGetUniformLocation id "ModelViewProjectionMatrix") 1 GL_FALSE mvp)
      void)))

;; when working with OpenGL
;; extempore's mmul is pre mutipled (not post as in GLSL)
;; so the same matrix mul is post in GLSL and pre in XTM (i.e. here!)
(bind-func shader_update_matrices_lv
  (let ((biasmc:float* (alloc 16))
        (biasmr:float* (alloc 16)))
    (pfill! biasmc
            0.5 0.0 0.0 0.0
            0.0 0.5 0.0 0.0
            0.0 0.0 0.5 0.0
            0.5 0.5 0.5 1.0)    
    (pfill! biasmr
            0.5 0.0 0.0 0.5
            0.0 0.5 0.0 0.5
            0.0 0.0 0.5 0.5
            0.0 0.0 0.0 1.0)   
    (lambda (id:i32 m:float* v p:float* lv:float*) ;; lv light view
      (let ((mlv:float* (salloc 16))
            (mlvp:float* (salloc 16))
            (mlvpb:float* (salloc 16)))
        (mmul m 4 4 lv 4 4 mlv)
        (mmul mlv 4 4 p 4 4 mlvp)
        (mmul mlvp 4 4 biasmc 4 4 mlvpb)
        (glUniformMatrix4fv (glGetUniformLocation id "LightModelViewProjectionMatrix") 1 GL_FALSE mlvpb))
      (let ((mv (salloc 48))
            (mvp (pref-ptr mv 16))
            (mn (pref-ptr mv 32)))
        (mmul m 4 4 v 4 4 mv) ;; final mv set
        (mtrans mv 4 4 mn) ;; using mn as a temporary here!!
        (minv mn 4 mvp) ;; using mvp as a temporary      
        (mat4_to_mat3 mvp mn)  ;; final mn set
        (mmul mv 4 4 p 4 4 mvp) ;; final mvp set
        (glUniformMatrix4fv (glGetUniformLocation id "ModelMatrix") 1 GL_FALSE m)
        (glUniformMatrix4fv (glGetUniformLocation id "ViewMatrix") 1 GL_FALSE v)
        (glUniformMatrix4fv (glGetUniformLocation id "ProjectionMatrix") 1 GL_FALSE p)
        (glUniformMatrix3fv (glGetUniformLocation id "NormalMatrix") 1 GL_FALSE mn)      
        (glUniformMatrix4fv (glGetUniformLocation id "ModelViewMatrix") 1 GL_FALSE mv)
        (glUniformMatrix4fv (glGetUniformLocation id "ModelViewProjectionMatrix") 1 GL_FALSE mvp)
        void))))


;; when working with OpenGL
;; extempore's mmul is pre mutipled (not post as in GLSL)
;; so the same matrix mul is post in GLSL and pre in XTM (i.e. here!)
(bind-func shader_update_matrices_lvs
  (let ((i:i32 0)
        (mlvpb:float* (alloc (* 10 16)))
        (biasmc:float* (alloc 16))
        (biasmr:float* (alloc 16)))
    (pfill! biasmc
            0.5 0.0 0.0 0.0
            0.0 0.5 0.0 0.0
            0.0 0.0 0.5 0.0
            0.5 0.5 0.5 1.0)    
    (pfill! biasmr
            0.5 0.0 0.0 0.5
            0.0 0.5 0.0 0.5
            0.0 0.0 0.5 0.5
            0.0 0.0 0.0 1.0)   
    (lambda (id:i32 m:float* v p:float* lights:i32 lv:float*) ;; lv is lights
      ;; view
      (dotimes (i lights)
        (let ((mlv:float* (salloc 16))
              (mlvp:float* (salloc 16)))
          (mmul m 4 4 (pref-ptr lv (* i 16)) 4 4 mlv)
          (mmul mlv 4 4 p 4 4 mlvp)
          (mmul mlvp 4 4 biasmc 4 4 (pref-ptr mlvpb (* i 16)))))
      (glUniformMatrix4fv (glGetUniformLocation id "LightModelViewProjectionMatrix")
                          lights GL_FALSE mlvpb)
      (let ((mv (salloc 48))
            (mvp (pref-ptr mv 16))
            (mn (pref-ptr mv 32)))
        (mmul m 4 4 v 4 4 mv) ;; final mv set
        (mtrans mv 4 4 mn) ;; using mn as a temporary here!!
        (minv mn 4 mvp) ;; using mvp as a temporary      
        (mat4_to_mat3 mvp mn)  ;; final mn set
        (mmul mv 4 4 p 4 4 mvp) ;; final mvp set
        (glUniformMatrix4fv (glGetUniformLocation id "ModelMatrix") 1 GL_FALSE m)
        (glUniformMatrix4fv (glGetUniformLocation id "ViewMatrix") 1 GL_FALSE v)
        (glUniformMatrix4fv (glGetUniformLocation id "ProjectionMatrix") 1 GL_FALSE p)
        (glUniformMatrix3fv (glGetUniformLocation id "NormalMatrix") 1 GL_FALSE mn)      
        (glUniformMatrix4fv (glGetUniformLocation id "ModelViewMatrix") 1 GL_FALSE mv)
        (glUniformMatrix4fv (glGetUniformLocation id "ModelViewProjectionMatrix") 1 GL_FALSE mvp)
        void))))


(bind-func shader_update_material
  (lambda (id:i32 ambient:float* diffuse:float* specular:float* shininess:float)
    (glUniform4fv (glGetUniformLocation id "MaterialAmbient") 1 ambient)
    (glUniform4fv (glGetUniformLocation id "MaterialDiffuse") 1 diffuse)
    (glUniform4fv (glGetUniformLocation id "MaterialSpecular") 1 specular)
    (glUniform1f (glGetUniformLocation id "MaterialShininess") shininess)
    void))


;; vbo(0),texid(1),diffuse(2),ambient(3),specular(4),emissive(5),shininess(6),opacity(7),facemode(8) (GL_TRIANGLE,GL_QUAD etc..)
(bind-type xtm_mesh <E_vbo*,i32,float*,float*,float*,float*,float,float,i32>)
;; name(0),transmat(1),parent(2),num_children(3),chidren(4),num_of_meshes(5),meshes(6)
(bind-type xtm_node <i8*,float*,xtm_node*,i32,xtm_node*,i32,xtm_mesh*>)

(bind-func xtm_build_mesh_vbo
  (lambda (verts:float* num_verts:i32)
    (let ((i:i32 0)
          (vert:float* null)
          (n1:float* (salloc 3))          
          (norm:float* (salloc 3))
          (vbostride:i32 14) ;; 4d+3d+3d+4d
          (vbodata:float* (halloc (* num_verts vbostride))))
      (dotimes (i num_verts)
        (set! vert (pref-ptr verts (* i 3)))
        (if (= (% i 3) 0)
            (if (> i (- num_verts 2))
                (begin (pfill! norm 0.0 1.0 0.0) 1)
                (begin
                  (vcrossf vert (pref-ptr vert 3) n1)
                  (vsmul -1.0 n1 3 norm)
                  1))
            1)
        (pfill! (pref-ptr vbodata (* i vbostride))
                (pref vert 0) ;; x 
                (pref vert 1) ;; y
                (pref vert 2) ;; z
                1.0) ;; position data needs w==1
        ;; auto gen normal
        (pfill! (pref-ptr vbodata (+ 4 (* i vbostride)))
                (pref norm 0)
                (pref norm 1)
                (pref norm 2))
        ;; auto gen texcoords
        (if (= (% i 3) 0)
            (pfill! (pref-ptr vbodata (+ 7 (* i vbostride))) 0.0 0.0 0.0)
            (if (= (% i 3) 1)
                (pfill! (pref-ptr vbodata (+ 7 (* i vbostride))) 0.5 1.0 0.0)
                (pfill! (pref-ptr vbodata (+ 7 (* i vbostride))) 1.0 0.0 0.0))
            0.0)
        ;; color is green
        (pfill! (pref-ptr vbodata (+ 10 (* i vbostride))) 0.2 1.0 0.2 1.0))
      (let ((vbo (create_vbo (* num_verts vbostride 4) (cast vbodata i8*) GL_STATIC_DRAW)))
        (glBindBuffer GL_ARRAY_BUFFER (tref vbo 0))        
        (glBufferData GL_ARRAY_BUFFER (tref vbo 1) (tref vbo 2) GL_STATIC_DRAW)
        (glBindBuffer GL_ARRAY_BUFFER 0)
        vbo))))

;;(bind-type xtm_mesh <E_vbo*,i32,float*,float*,float*,float*,float,float,i32>)

(bind-func xtm_make_node_a
  (lambda (name:i8* verts:float* num_verts:i32 r g b)
    (let ((mesh:xtm_mesh* (halloc))
          (node:xtm_node* (halloc))
          (transmat:float* (halloc 16))
          (vbostride:i32 14) ;; 4d+3d+3d+4d
          (vbodata:float* null)
          (shininess:float 1.0)
          (opacity:float 1.0)
          (diffuse:float* (halloc 4))
          (ambient:float* (halloc 4))
          (specular:float* (halloc 4))
          (emissive:float* (halloc 4))
          (vbo:E_vbo* (xtm_build_mesh_vbo verts num_verts)))
      (pfill! ambient 0.0 0.0 0.0 1.0)
      (pfill! diffuse r   g   b   1.0)
      (pfill! specular 1.0 1.0 1.0 1.0)
      (pfill! emissive 0.0 0.0 0.0 1.0)
      (tfill! mesh vbo 0 diffuse ambient specular emissive shininess opacity GL_TRIANGLES)
      (fill_identity_matrix transmat)
      (tfill! node name transmat null 0 null 1 mesh)
      node)))

(bind-poly xtm_make_node xtm_make_node_a)

(bind-type xtm_camera <float*,float*,float*>)

(bind-func xtm_get_camera
  (let ((camera:xtm_camera* (zalloc))
        (p:float* (zalloc 4))
        (t:float* (zalloc 4))
        (u:float* (zalloc 4)))
    (pfill! p 0.0 5.0 10.0)
    (pfill! t 0.0 2.0 0.0)
    (pfill! u 0.0 1.0 0.0)
    (tfill! camera p t u)
    (lambda ()
      camera)))
      
(bind-func xtm_camera_pos
  (lambda (x y z)
   (pfill! (tref (xtm_get_camera) 0) x y z 1.0)
   void))

(bind-func xtm_camera_tgt
  (lambda (x y z)
    (pfill! (tref (xtm_get_camera) 1) x y z 1.0)
    void))

(bind-func xtm_camera_up
  (lambda (x y z)
    (pfill! (tref (xtm_get_camera) 2) x y z 0.0)
    void))

(bind-func xtm_camera_view
  (let ((camera:xtm_camera* null))
    (lambda (view:float*)
      (set! camera (xtm_get_camera))
      (fill_view_matrix view (tref camera 0) (tref camera 1) (tref camera 2))
      void)))

(bind-func xtm_update_camera
  (lambda (shader)
    (shader_update_camera shader (tref (xtm_get_camera) 0) (tref (xtm_get_camera) 1))
    void))


;; position(0) target(1) up(2) ambient(3) diffuse(4) specular(5) power(6) angle(7) matrices(8) numlights(9)
;; (bind-type xtm_light <|40,float|,|40,float|,|40,float|,|40,float|,|40,float|,|40,float|,|10,float|,|10,float|>)
;; (bind-type xtm_lights <|40,float|,|40,float|,|40,float|,|40,float|,|40,float|,|40,float|,|10,float|,|10,float|>)
(bind-type xtm_lights <float*,float*,float*,float*,float*,float*,float*,float*,float*,i32>)

(bind-func xtm_get_lights
  (let ((i 0)
        (lights:xtm_lights* (zalloc))
        (p:float* (zalloc (* 10 4)))
        (t:float* (zalloc (* 10 4)))
        (u:float* (zalloc (* 10 4)))
        (a:float* (zalloc (* 10 4)))
        (d:float* (zalloc (* 10 4)))
        (s:float* (zalloc (* 10 4)))
        (pow:float* (zalloc 10))
        (ang:float* (zalloc 10))
        (matrices:float* (zalloc (* 10 16))))
    (dotimes (i 10)
      (pfill! (pref-ptr d (* i 4)) 1.0 0.8 0.5 1.0)
      (pfill! (pref-ptr s (* i 4)) 1.0 1.0 1.0 1.0)
      (pfill! (pref-ptr a (* i 4)) 1.0 0.8 0.5 1.0)
      (pfill! (pref-ptr p (* i 4)) 1.0 10.0 10.0 1.0)
      (pfill! (pref-ptr t (* i 4)) 0.0 0.0 0.0 1.0) ;;looking at origin
      (pfill! (pref-ptr u (* i 4)) 0.0 1.0 0.0 0.0)
      (pfill! (pref-ptr ang i) 60.0)
      (pfill! (pref-ptr pow i) 30.0)
      (fill_view_matrix (pref-ptr matrices (* i 16))
                        (pref-ptr p (* i 4)) ;; position
                        (pref-ptr t (* i 4)) ;; target
                        (pref-ptr u (* i 4)))) ;; up
    (tfill! lights p t u a d s pow ang matrices 0)
    (lambda ()
      lights)))

(bind-func xtm_light_pos
  (let ((lights:xtm_lights* null))
    (lambda (light:i32 x y z)
      (set! lights (xtm_get_lights))
      (if (> light (tref lights 9)) (tset! lights 9 light))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)
          (let ((a:float* (pref-ptr (tref lights 0) (* light 4))))
            (pfill! a x y z 1.0)
            void)))))

(bind-func xtm_light_tgt
  (let ((lights:xtm_lights* null))  
    (lambda (light:i32 x y z)
      (set! lights (xtm_get_lights))
      (if (> light (tref lights 9)) (tset! lights 9 light))          
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)        
          (let ((a:float* (pref-ptr (tref lights 1) (* light 4))))
            (pfill! a x y z 1.0)
            void)))))

(bind-func xtm_light_up
  (let ((lights:xtm_lights* null))    
    (lambda (light:i32 x y z)
      (set! lights (xtm_get_lights))      
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)                
          (let ((a:float* (pref-ptr (tref lights 2) (* light 4))))
            (pfill! a x y z 0.0)
            void)))))

(bind-func xtm_light_ambient
  (let ((lights:xtm_lights* null))        
    (lambda (light:i32 r g b a)
      (set! lights (xtm_get_lights))      
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)                
          (let ((arr:float* (pref-ptr (tref lights 3) (* light 4))))
            (pfill! arr r g b a)
            void)))))

(bind-func xtm_light_diffuse
  (let ((lights:xtm_lights* null))        
    (lambda (light:i32 r g b a)
      (set! lights (xtm_get_lights))      
      (if (> light (tref lights 9)) (tset! lights 9 light))          
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)                
          (let ((arr:float* (pref-ptr (tref lights 4) (* light 4))))
            (pfill! arr r g b a)
            void)))))

(bind-func xtm_light_specular
  (let ((lights:xtm_lights* null))    
    (lambda (light:i32 r g b a)
      (set! lights (xtm_get_lights))      
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)                
          (let ((arr:float* (pref-ptr (tref lights 5) (* light 4))))
            (pfill! arr r g b a)
            void)))))

(bind-func xtm_light_power
  (let ((lights:xtm_lights* null))        
    (lambda (light:i32 power)
      (set! lights (xtm_get_lights))      
      (if (> light (tref lights 9)) (tset! lights 9 light))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)                
          (begin (pset! (tref lights 6) light power) void)))))

(bind-func xtm_light_angle
  (let ((lights:xtm_lights* null))        
    (lambda (light:i32 angle)
      (set! lights (xtm_get_lights))      
      (if (> light (tref lights 9)) (tset! lights 9 light))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)        
          (begin (pset! (tref lights 7) light angle) void)))))

(bind-func xtm_light_view
  (let ((lights:xtm_lights* null))
    (lambda (light:i32 view:float*)
      (set! lights (xtm_get_lights))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)            
          (begin (fill_view_matrix (pref-ptr (tref lights 8) (* light 16))
                                   (pref-ptr (tref lights 0) (* light 4)) ;; position
                                   (pref-ptr (tref lights 1) (* light 4)) ;; target
                                   (pref-ptr (tref lights 2) (* light 4))) ;; up
                 (if (not (null? view))
                     (mcopy (pref-ptr (tref lights 8) (* light 16)) 4 4 view))
                 void)))))

(bind-func xtm_update_lights
  (lambda (shader:i32)
    (let ((lights (xtm_get_lights)))
      (shader_update_lights shader (tref lights 9)
                            (tref lights 0) (tref lights 1)
                            (tref lights 7) (tref lights 6)
                            (tref lights 3) (tref lights 4)
                            (tref lights 5)))))

(bind-func xtm_update_matrices
  (lambda (shader:i32 model:float* view:float* projection:float*)
    (let ((lights (xtm_get_lights)))
      (shader_update_matrices_lvs shader model view projection (tref lights 9) (tref lights 8)))))

(bind-func xtm_draw_mesh
  (let ((vert:i32 0)
        (first -1)
        (norm:i32 1)
        (uvw:i32 2)
        (color:i32 3))
    (lambda (mesh:xtm_mesh* shader:i32)
      ;; (printf "draw mesh\n")
      (let ((vbo (tref mesh 0))
            (texid (tref mesh 1))
            (diffuse (tref mesh 2))
            (ambient (tref mesh 3))
            (specular (tref mesh 4))
            (shininess (tref mesh 6))
            (facemode (tref mesh 8)))
        (set! shininess (dtof 100.0))
        (if (not (null? ambient))
            (glUniform4fv (glGetUniformLocation shader "MaterialAmbient") 1 ambient))
        (if (not (null? diffuse))
            (glUniform4fv (glGetUniformLocation shader "MaterialDiffuse") 1 diffuse))
        (if (not (null? specular))
            (glUniform4fv (glGetUniformLocation shader "MaterialSpecular") 1 specular))
        (glUniform1f (glGetUniformLocation shader "MaterialShininess") shininess)
        ;; (printf "texid %d\n" texid)
        ;; texture stuff
        (if (> texid 0)
            (begin
              (glActiveTexture GL_TEXTURE2)
              
              (glBindTexture GL_TEXTURE_2D texid)
              (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_S GL_CLAMP_TO_EDGE)
              (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_T GL_CLAMP_TO_EDGE)
              (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_LINEAR)
              (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER GL_LINEAR)
              (glUniform1f (glGetUniformLocation shader "IsTextured") 1.0)
              (glUniform1i (glGetUniformLocation shader "tex1") 2))
            (begin
              (glUniform1f (glGetUniformLocation shader "IsTextured") 0.0)))
        ;; vbo stuff
        (glBindBuffer GL_ARRAY_BUFFER (tref vbo 0))
        (glEnableVertexAttribArray vert) ;; 56
        (glVertexAttribPointer vert 4 GL_FLOAT GL_FALSE 56 null)
        (glEnableVertexAttribArray norm) 
        (glVertexAttribPointer norm 3 GL_FLOAT GL_FALSE 56 (pref-ptr (cast null i8*) 16))
        (glEnableVertexAttribArray uvw) 
        (glVertexAttribPointer uvw 3 GL_FLOAT GL_FALSE 56 (pref-ptr (cast null i8*) 28))
        (glEnableVertexAttribArray color) 
        (glVertexAttribPointer color 4 GL_FLOAT GL_FALSE 56 (pref-ptr (cast null i8*) 40))
        (glDrawArrays facemode 0 (/ (tref vbo 1) 56))
        (glDisableVertexAttribArray vert)
        (glDisableVertexAttribArray norm)
        (glDisableVertexAttribArray uvw)
        (glDisableVertexAttribArray color)
        (glBindBuffer GL_ARRAY_BUFFER 0)
        ;; undo texture stuff
        (glActiveTexture GL_TEXTURE2)
        (glBindTexture GL_TEXTURE_2D 0)
        void))))


(bind-func xtm_draw_node
  (lambda (node:xtm_node* shader:i32 model:float* view:float* projection:float*)
    (let ((i:i32 0)
          (lights (xtm_get_lights))
          (children (tref node 4))
          (meshes (tref node 6))
          (transmat:float* (tref node 1))
          (m2:float* (salloc 16))
          (m:float* (salloc 16)))
      ;; (printf "draw node: %s\n" (tref node 0))
      ;;(mprint transmat 4 4 1)      
      ;;(mprintf model 4 4 1)
      (if (null? transmat)
          (begin (memcpy (cast m i8*) (cast model i8*) (* 4 16)) 1)
          (begin
            (mtrans transmat 4 4 m2)
            (mmul m2 4 4 model 4 4 m)
            1))
      (xtm_update_matrices shader m view projection)
      ;; first draw meshes
      (dotimes (i (tref node 5))
        (xtm_draw_mesh (pref-ptr meshes i) shader))
      ;; then draw other children recursively
      (dotimes (i (tref node 3))
        (xtm_draw_node (pref-ptr children i) shader model view projection))
      void)))


(bind-func xtm_draw_model
  (lambda (scene:xtm_node* shader:i32 model view projection)
    (xtm_draw_node scene shader model view projection)
    void))

(bind-val xtm_render_s1 i32 0)
(bind-val xtm_render_s2 i32 0)
(bind-val xtm_render_s3 i32 0)
(bind-val xtm_render_s4 i32 0)
(bind-val xtm_render_x i32 0)
(bind-val xtm_render_y i32 0)
(bind-val xtm_render_w i32 1024)
(bind-val xtm_render_h i32 768)
(bind-val xtm_render_angle float 35.0)
(bind-val xtm_render_near float 0.1)
(bind-val xtm_render_far float 100.0)


(bind-func xtm_draw_tex
  (lambda (shader:i32 tex:i32 m v p)
    (glUseProgram shader)
    (shader_update_matrices shader m v p)
    ;; setup shadowmap texture from FBO
    (glActiveTexture GL_TEXTURE0) ;; texture unit 0 for shadowMap
    (glBindTexture GL_TEXTURE_2D tex)
    (glUniform1i (glGetUniformLocation shader "tex1") 0)
    ;; (glViewport x y w h)
    (gl_draw_shader_quad 0.0 0.0 1.0 1.0 0.0 1.0 1.0)
    (glBindTexture GL_TEXTURE_2D 0)
    (glUseProgram 0)
    void))


(bind-func xtm_render_fbo
  (let ((fbo:E_fbo* null))
    (lambda ()
      (if (null? fbo) (set! fbo (create_fbo (ftoi32 (* 4.0 1024.0)) (ftoi32 (* 4.0 1024.0)) 0 0)))
      fbo)))

(bind-func xtm_render_setup_a
  (lambda (w h s1v:i8* s1f:i8* s2v:i8* s2f:i8* s2f_nl:i8* s4v:i8* s4f:i8*)
    (xtm_render_fbo)    
    (set! xtm_render_w w)
    (set! xtm_render_h h)
    (set! xtm_render_s1 (create_shader_xtm s1v s1f))
    (set! xtm_render_s2 (create_shader_xtm s2v s2f))
    (set! xtm_render_s3 (create_shader_xtm s2v s2f_nl))
    (set! xtm_render_s4 (create_shader_xtm s4v s4f))
    (printf "XTM Render Setup Complete\n")
    void))

(bind-func xtm_render_setup_b
  (lambda (w h n f s1v s1f s2v s2f s2f_nl s4v s4f)
    (set! xtm_render_near n)
    (set! xtm_render_far f)
    (xtm_render_setup_a w h s1v s1f s2v s2f s2f_nl s4v s4f)     
    void))

(bind-func xtm_render_setup_c
  (lambda (x y w h n f a s1v s1f s2v s2f s2f_nl s4v s4f)
    (set! xtm_render_x x)
    (set! xtm_render_y y)
    (set! xtm_render_angle a)
    (xtm_render_setup_b w h n f s1v s1f s2v s2f s2f_nl s4v s4f)
    void))

(bind-poly xtm_render_setup xtm_render_setup_a)
(bind-poly xtm_render_setup xtm_render_setup_b)
(bind-poly xtm_render_setup xtm_render_setup_c)

(define xtm_render_setup
  (lambda (w h . args)
    (if (null? args)
        (xtm_render_setup_a w h
                            simple-vert-xtm simple-frag
                            xtmvert-xtm xtmfrag xtmfrag_nolight
                            quad-vert quad-frag)
        (cond ((= (length args) 2)
               (xtm_render_setup_b w h (car args) (cadr args)
                                   simple-vert-xtm simple-frag
                                   xtmvert-xtm xtmfrag xtmfrag_nolight
                                   quad-vert quad-frag))
              ((= (length args) 5)
               (xtm_render_setup_c w h (car args) (cadr args)
                                   (caddr args) (cadddr args)
                                   (car (cddddr args))
                                   simple-vert-xtm simple-frag
                                   xtmvert-xtm xtmfrag xtmfrag_nolight
                                   quad-vert quad-frag))
              (else (println 'Wrong 'number 'or 'args 'for 'xtm_render_setup))))))


(bind-alias XTMRENDERCB [void,i64,i32,float*,float*,float*,i8*]*)

;;
;; near  = 0.1
;; far   = 100.0
;; angle = 35.0
;;
(bind-func xtm_render
  (let ((i:i32 0)
        (frame:i64 0)
        (lights:xtm_lights* (xtm_get_lights))
        (camera:xtm_camera* (xtm_get_camera))
        (activelights:i32 0)
        (sh1:i32 0)
        (sh2:i32 0)
        (model:float* (alloc 16))
        (view:float* (alloc 16))
        (projection:float* (alloc 16))
        (fbo:E_fbo* null))
    (lambda (pre:XTMRENDERCB opaque:XTMRENDERCB transparent:XTMRENDERCB post:XTMRENDERCB data:i8*)
      (set! fbo (xtm_render_fbo))
      (glShadeModel GL_SMOOTH)
      (glEnable GL_DEPTH_TEST)
      (glEnable GL_TEXTURE_2D)
      ;; seutp projection matrix            
      (fill_projection_matrix projection xtm_render_angle
                              (i32tof (/ xtm_render_w xtm_render_h))
                              xtm_render_near xtm_render_far)

      (if (not (null? pre))
          (begin
            ;; each cycle set lights back to 0
            (tset! (xtm_get_lights) 9 0)            
            (xtm_camera_view view)       ;; set view
            (fill_identity_matrix model) ;; set model
            (pre frame 0 model view projection data)))

      (glBindFramebuffer GL_FRAMEBUFFER (tref fbo 0))
      (set! sh1 xtm_render_s1)
      (glUseProgram sh1)
      ;; clear shadow buffer
      (glClearColor 0.0 0.0 0.0 1.0)
      (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
      (if (not (null? opaque))
          (dotimes (i (tref lights 9))
            ;; 4 x 4 shadow texture texture
            (glViewport (* (% i 4) 1024) (* (ftoi32 (/ (i32tof i) 4.0)) 1024) 1024 1024)
            (glEnable GL_CULL_FACE) ;; face culling ON for shadowmapping
            (glCullFace GL_FRONT)
            (fill_identity_matrix model)  ;; set model matrix
            (xtm_light_view (+ i 1) view) ;; set view matrix
            (xtm_update_matrices sh1 model view projection)
            (opaque frame sh1 model view projection data)))
      ;; turn off shadow FBO
      (glBindFramebuffer GL_FRAMEBUFFER 0)
      (glUseProgram 0)
      ;;
      (set! activelights (tref lights 9))      
      ;;
      ;; Finally render the scene to the window
      ;; using the shadow FBO's depth buffer as a shadow map
      ;;      
      ;; make sure we are not writing to a framebuffer!
      (glBindFramebuffer GL_FRAMEBUFFER 0)
      (set! sh2 (if (> activelights 0) xtm_render_s2 xtm_render_s3))
      (glUseProgram sh2)
      ;; setup shadowmap texture from FBO
      (glActiveTexture GL_TEXTURE0) ;; texture unit 0 for shadowMap
      (glBindTexture GL_TEXTURE_2D (tref fbo 2))      
      (glUniform1i (glGetUniformLocation sh2 "shadowMap") 0)      
      ;;(shader_update_matrices_lvs shadowshader model_matrix view_matrix projection_matrix lights _light_view_matrix)
      ;; draw scene
      (glViewport xtm_render_x xtm_render_y xtm_render_w xtm_render_h)
      (glDisable GL_CULL_FACE) ;; turn face culling off
      ;; clear main framebuffer
      (glClearColor 0.0 0.0 0.0 1.0)
      (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
      (if (not (null? opaque))
          (begin
            ;; setup matrices
            (xtm_camera_view view)       ;; setup view
            (fill_identity_matrix model) ;; setup model
            (xtm_update_lights sh2) ;; update lights on shader
            (xtm_update_camera sh2) ;; update camera on shader
            (xtm_update_matrices sh2 model view projection) ;; update mats on shader
            (opaque frame sh2 model view projection data)))
      ;; turn everything off again.
      (glActiveTexture GL_TEXTURE0)
      (glBindTexture GL_TEXTURE_2D 0)
      ;;
      (glBindFramebuffer GL_FRAMEBUFFER 0)
      (glUseProgram 0)

      (if (not (null? post))
          (begin
            ;; post is usually 2D? so no DEPTH test by default!
            (glDisable GL_DEPTH_TEST)                  
            (xtm_camera_view view)       ;; setup view
            (fill_identity_matrix model) ;; setup model
            ;; should probably really pass in 0 for shader id here!
            ;; as we don't want ANY shaders running by default in
            ;; the post processing stage.
            (post frame xtm_render_s4 model view projection data)))
      ;;
      (glDisable GL_TEXTURE_2D) ;; unbind texture unit 0      
      ;; print errors?
      (gl_print_error)
      (set! frame (+ frame 1))
    )))


;; vert shader
(define passthrough-vert
"// VERTEX SHADER
// #version 330

varying vec2 TexCoord;
 
void main() {   
   // pass through texture coordinate
   //TexCoord =  gl_TextureMatrix[0].st * gl_MultiTexCoord0.st;   
   TexCoord = gl_MultiTexCoord0.st;
   gl_FrontColor = gl_Color;
   //gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; //this same as line below
   gl_Position = ftransform();
}")


;; frag shader
(define passthrough-frag
"//  FRAGMENT SHADER
// #version 330
#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2DRect(tex1,TexCoord);
}")


;; frag shader
(define greyscale-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   float grey = dot(texture2DRect(tex1,TexCoord).rgb, vec3(0.299, 0.587, 0.114));
   gl_FragColor = vec4(vec3(grey),alpha);
}")


;; sepia
(define sepia-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   float grey = dot(texture2DRect(tex1,TexCoord).rgb, vec3(0.299, 0.587, 0.114));
   gl_FragColor = vec4(grey*vec3(1.2,1.0,0.8),alpha);
}")


(define invert-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   vec4 colour = texture2DRect(tex1,TexCoord);
   gl_FragColor = vec4(1.0 - colour.rgb,alpha);
}")


(define gaussian-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
   vec4 sample[25];
   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
   }
 
   gl_FragColor = ((1.0  * (sample[0] + sample[4]  + sample[20] + sample[24])) +
	           (4.0  * (sample[1] + sample[3]  + sample[5]  + sample[9] + sample[15] + sample[19] + sample[21] + sample[23])) +
	           (7.0  * (sample[2] + sample[10] + sample[14] + sample[22])) +
	           (16.0 * (sample[6] + sample[8]  + sample[16] + sample[18])) +
	           (26.0 * (sample[7] + sample[11] + sample[13] + sample[17])) +
	           (41.0 * sample[12])
	           ) / 273.0;
   //gl_FragColor = vec4(1.0,0.0,0.0,1.0);
}")


;;  Blur (median filter)
(define blur-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
   gl_FragColor = vec4(0.0);
 
   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      gl_FragColor += texture2DRect(tex1, TexCoord + texoffset[i]);
   }
 
   gl_FragColor /= 25.0;
}")


;;  sharpen
(define sharpen-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
    vec4 sample[25];
 
    for (int i = 0; i < 25; i++)
    {
       // Sample a grid around and including our texel
       sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
    }
  
    gl_FragColor = 25.0 * sample[12];
 
    for (int i = 0; i < 25; i++)
    {
       if (i != 12)
          gl_FragColor -= sample[i];
    }
}")

(define dilate-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {  
   vec4 sample[25];
   vec4 maxValue = vec4(0.0);
 
   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
 
      // Keep the maximum value		
      maxValue = max(sample[i], maxValue);
   }
 
   gl_FragColor = maxValue;
}")


(define erode-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
    vec4 sample[25];
    vec4 minValue = vec4(1.0);
 
    for (int i = 0; i < 25; i++)
    {
        // Sample a grid around and including our texel
        sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
 
        // Keep the minimum value		
        minValue = min(sample[i], minValue);
    }
    gl_FragColor = minValue;
}")


(define edge-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
    vec4 sample[25];
 
    for (int i = 0; i < 25; i++)
    {
       // Sample a grid around and including our texel
       sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
    }

    gl_FragColor = 24.0 * sample[12];
 
    for (int i = 0; i < 25; i++)
    {
	if (i != 12)
	   gl_FragColor -= sample[i];
    }
}")


(define blend-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect baseBuf;
uniform sampler2DRect blendBuf;
uniform float       time;
uniform float       opacity;

varying vec2 TexCoord;

void main() {
    vec4 base = texture2DRect(baseBuf, TexCoord);
    vec4 blend = texture2DRect(blendBuf, TexCoord);

    vec4 result = blend + base;
         result = clamp(result, 0.0, 1.0);

    gl_FragColor = mix(base, result, opacity);
}")


;; vert shader
(define particles-vert
"// VERTEX SHADER
// GLSL 1.2 compatible

//varying vec2 TexCoord;

attribute vec2 myVertex;
attribute vec4 myColour;
attribute float mySize;
attribute vec2 myVelocity;
attribute float myState;

void main() {
   gl_PointSize = mySize;
   if(myState > 0.0) {
     gl_FrontColor = myColour;
   }else{
     gl_FrontColor = vec4(0.0,0.0,0.0,0.0);
   }
   gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * vec4(myVertex.xy,0.0,1.0);
   //TexCoord = gl_MultiTexCoord0.st;
}")

(define particles-frag
"//  FRAGMENT SHADER
// #version 330

#version 120

#extension GL_ARB_texture_rectangle : disable

uniform sampler2D tex1;

//varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2D(tex1,gl_PointCoord)*gl_Color;
   //gl_FragColor = gl_Color;
}")


(define green-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex_back;
uniform sampler2DRect tex_front;
uniform vec4 color;
uniform float width;
uniform float height;
uniform float scale_front;
uniform int flipx;
uniform int flipy;

varying vec2 TexCoord;

void main() {
    vec4 base = texture2DRect(tex_back, TexCoord);
    float x = (flipx==0) ? TexCoord.x : width-TexCoord.x;
    float y = (flipy==0) ? TexCoord.y : height-TexCoord.y;
    vec4 blend = texture2DRect(tex_front, vec2(x*scale_front,y*scale_front));

    if(color == blend) {
      gl_FragColor = base;
    }else{
      gl_FragColor = blend;
    }
}")


(define dof-frag
"
#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect dBuf;
uniform sampler2DRect cBuf;
//uniform vec2 frameBufSize;
uniform float blur;
uniform float fp;  // focal point
uniform int show_depth;
uniform float dfact; // depth factor (shorten or make longer)
uniform float near;
uniform float far;

varying vec2 TexCoord;

// const float near = 0.1;
// const float far = 1000.0;
const vec2 frameBufSize = vec2(1.0,1.0);

vec4 blurKawase( const sampler2DRect tex, const vec2 texCoord, const vec2 texSize, const float iteration ) {
	// Function assumes that tex is using bilinear hardware filtering
	
	vec2 dUV = (iteration + 0.5) / texSize;
	
	vec4 col = texture2DRect( tex, texCoord + vec2( -dUV.x, dUV.y ) );	// Top left
	col += texture2DRect( tex, texCoord + dUV );		        // Top right
	col += texture2DRect( tex, texCoord + vec2( dUV.x, -dUV.y ) );      // Bottom right
	col += texture2DRect( tex, texCoord - dUV );		        // Bottom left
	
	return col * 0.25;
}

void main( void ) {
        // get z depth from dBuf tex 
	float depth = texture2DRect(dBuf,TexCoord).x;	

        // scale depth buffer
        depth *= far-near;
        depth = (far+near)-depth;
        depth = abs(depth - fp); // fp focal point

        // show_depth is true display depth buffer
        if (show_depth == 1) {
          gl_FragColor = vec4(depth,depth,depth,1.0);  
        } else { // else apply depth blur
          gl_FragColor = blurKawase( cBuf, TexCoord, frameBufSize, depth * blur);
        }
}
")


(define light-vert
  "
//#version 120
#version 120
varying vec3 N, L, E, V;
varying float D;
uniform vec4 LightPos;
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main()
{
  gl_Position = ModelViewProjectionMatrix * gl_Vertex;
  vec4 vPosition = ModelViewMatrix * gl_Vertex;
  //gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * gl_Vertex;
  //vec4 vPosition = ViewMatrix * ModelMatrix * gl_Vertex;
  N = NormalMatrix * gl_Normal; //normal
  L = (LightPos - (ModelMatrix * gl_Vertex)).xyz; // vector from source to light
  if(LightPos.w == 0.0) L = LightPos.xyz; // i.e. if LightPos is already a direction vector
  D = length(L); // distance from source to light
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
}
")

(define light-frag
  "
#version 120
varying vec3 N, L, E, V;
varying float D;
uniform vec4 LightAmbient;
uniform vec4 LightDiffuse;
uniform vec4 LightSpecular;
uniform float ConstantAttenuation;
uniform float LinearAttenuation;
uniform float QuadraticAttenuation;
uniform float SpotAngle;
uniform vec4 SpotDir;
uniform float SpotExponent;
uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main()
{
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;

  vec3 NN = normalize(N); // surface normal
  vec3 LL = normalize(L); // light vector
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d
  vec4 Color = vec4(0.0,0.0,0.0,0.0);

  attenuation = 1.0 / (ConstantAttenuation + (LinearAttenuation * D) + (QuadraticAttenuation * D * D));

  spotDot = dot(-LL, normalize(SpotDir.xyz));

  if(spotDot < SpotAngle)
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient * MaterialAmbient * attenuation;
  diffuse = LightDiffuse * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular * MaterialSpecular * pf * attenuation;

  gl_FragColor = vec4((ambient + diffuse + specular).xyz,1.0);
}
")

(define simple-vert
  "
uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main() {   
   gl_Position = ModelViewProjectionMatrix * gl_Vertex;
}
")

(define simple-vert-xtm
  "
uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

void main() {   
   gl_Position = ModelViewProjectionMatrix * xtmVertex;
}
")

(define simple-frag
  "

void main() {
   gl_FragColor = vec4(1.0,0.0,0.0,1.0);
}
")

(define quad-vert
  "
#version 120

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

varying vec2 TexCoord;
 
void main() {   
   TexCoord = gl_MultiTexCoord0.st;
   gl_FrontColor = gl_Color;
   gl_Position = ModelViewProjectionMatrix * gl_Vertex;
}
")

(define quad-frag
  "
uniform sampler2D tex1;
varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2D(tex1,TexCoord);
}
")

(define light-and-shade-vert-xtm
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, L, E, V;
varying float D;

uniform vec4 LightPos;
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix;

varying vec4 lightVertexPosition;
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  L = (LightPos - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos.w == 0.0) L = LightPos.xyz; // i.e. if LightPos is already a direction vector
  D = length(L); // distance from source to light
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;
  lightVertexPosition = LightModelViewProjectionMatrix * xtmVertex;
}
")


(define light-and-shade-frag
  "
//#version 120
varying vec3 N, L, E, V;
varying float D;

uniform vec4 LightAmbient;
uniform vec4 LightDiffuse;
uniform vec4 LightSpecular;
uniform float ConstantAttenuation;
uniform float LinearAttenuation;
uniform float QuadraticAttenuation;
uniform float SpotAngle;
uniform vec4 SpotDir;
uniform float SpotExponent;
uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured; 

varying vec4 lightVertexPosition;
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color
  
  vec3 NN = normalize(N); // surface normal
  vec3 LL = normalize(L); // light vector
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  attenuation = 1.0 / (ConstantAttenuation + (LinearAttenuation * D) + (QuadraticAttenuation * D * D));

  spotDot = dot(-LL, normalize(SpotDir.xyz));

  if(spotDot < SpotAngle)
    spotAttenuation = 0.0;

else
    spotAttenuation = pow(spotDot, SpotExponent);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient * MaterialAmbient * attenuation;
  diffuse = LightDiffuse * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition;
  lightVertexPosition2 /= lightVertexPosition2.w;

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,lightVertexPosition2.xy+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
     vec4 texcolor = LightDiffuse * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
     gl_FragColor = vec4((texcolor.xyz*shadowValue),1.0);
  } else {
     gl_FragColor = vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }
}
")


(define xtmvert-xtm
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;
  for(int i=0; j<numlights; i++, j+=1.0) {
    L[i] = (LightPos[i] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
    if(LightPos[i].w == 0.0) L[i] = LightPos[i].xyz; // i.e. if LightPos is already a direction vector
    D[i] = length(L[i]);
    lightVertexPosition[i] = LightModelViewProjectionMatrix[i] * xtmVertex;
  }
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;  
}
")


(define xtmfrag
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  for(int i=0; j<numlights; i++, j+=1.0) 
  {  
    vec3 LL = normalize(L[i]); // light vector
    attenuation = 1.0 / (ConstantAttenuation[i] + (LinearAttenuation[i] * D[i]) + (QuadraticAttenuation[i] * D[i] * D[i]));
    spotDot = dot(-LL, normalize(SpotDir[i].xyz));

    if(spotDot < SpotAngle[i])
      spotAttenuation = 0.0;
    else
      spotAttenuation = pow(spotDot, SpotExponent[i]);  

    attenuation *= spotAttenuation;

    HV = normalize(LL+EE); // half vector
    nDotLL = max(0.0, dot(NN,LL));
    nDotHV = max(0.0, dot(NN,HV));

    if(nDotLL==0.0)
      pf = 0.0;
    else
      pf = pow(nDotHV, MaterialShininess);

    ambient = LightAmbient[i] * MaterialAmbient * attenuation;
    diffuse = LightDiffuse[i] * MaterialDiffuse * nDotLL * attenuation;
    specular = LightSpecular[i] * MaterialSpecular * pf * attenuation;

    //calc shadows
    float shadowValue = 0.0;
    vec4 lightVertexPosition2 = lightVertexPosition[i];
    lightVertexPosition2 /= lightVertexPosition2.w;

    float aa = mod((j-0.5),4.0);
    float bb = floor((j-0.5)/4.0);
    vec2 offset = vec2(0.25*aa,0.25*bb);

    // softer shadowing by adding dither
    for(float x=-0.0004; x<=0.0004; x+=0.0002) {
      for(float y=-0.0004; y<=0.0004; y+=0.0002) {
        if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
          shadowValue+=1.0;
      }
    }
    shadowValue/=16.0;

    if(IsTextured>0.5) {
      vec4 texcolor = LightDiffuse[i] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
      outcolor += vec4((texcolor.xyz*shadowValue),1.0);
    } else {
      outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
    }
  }
  float nl = numlights;
  if(numlights<0.5) {
    nl = 1.0;
    float dotE = max(0.0, dot(NN,EE));
    if(IsTextured>0.5) {
      outcolor.xyz = texture2D(tex1,UVWCoord.xy).xyz*dotE;
    }else{
      outcolor.xyz = MaterialDiffuse.xyz*dotE;
    }
  }
  gl_FragColor = vec4(outcolor.xyz/nl,1.0);
}
")


(define xtmfrag_nolight
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  float dotE = max(0.0, dot(NN,EE));
  if(IsTextured>0.5) {
    outcolor.xyz = texture2D(tex1,UVWCoord.xy).xyz*dotE;
  }else{
    outcolor.xyz = MaterialDiffuse.xyz*dotE;
  }
  gl_FragColor = vec4(outcolor.xyz,1.0);
}
")

